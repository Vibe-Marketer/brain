---
phase: 09-bank-vault-architecture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260131000002_create_banks_tables.sql
autonomous: true

must_haves:
  truths:
    - "banks table exists with id, name, type, cross_bank_default, timestamps"
    - "bank_memberships table exists with user-bank relationship and role"
    - "RLS policies enforce bank isolation"
  artifacts:
    - path: "supabase/migrations/20260131000002_create_banks_tables.sql"
      provides: "Banks and BankMemberships tables with RLS"
      contains: "CREATE TABLE banks"
  key_links:
    - from: "bank_memberships"
      to: "banks"
      via: "FK bank_id"
      pattern: "REFERENCES banks\\(id\\)"
    - from: "bank_memberships"
      to: "auth.users"
      via: "FK user_id"
      pattern: "REFERENCES auth\\.users\\(id\\)"
---

<objective>
Create the banks and bank_memberships tables with proper constraints, indexes, and RLS policies. This establishes the top-level tenant isolation layer for the Bank/Vault architecture.

Purpose: Banks are the hard security boundary - nothing crosses banks unless explicitly copied. This migration creates the foundation for multi-tenant isolation.
Output: Two tables (banks, bank_memberships) with complete RLS policies and helper functions.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-bank-vault-architecture/09-CONTEXT.md
@.planning/phases/09-bank-vault-architecture/09-RESEARCH.md
@docs/planning/CallVault-Final-Spaces.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create banks table with constraints</name>
  <files>supabase/migrations/20260131000002_create_banks_tables.sql</files>
  <action>
Create migration file with the banks table:

```sql
-- Banks: Top-level tenant container
-- Each bank is a completely separate security boundary
CREATE TABLE IF NOT EXISTS banks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('personal', 'business')),
  cross_bank_default TEXT DEFAULT 'copy_only' CHECK (cross_bank_default IN ('copy_only', 'copy_and_remove')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for banks
CREATE INDEX IF NOT EXISTS idx_banks_type ON banks(type);

-- Updated_at trigger for banks
CREATE OR REPLACE FUNCTION update_banks_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS banks_updated_at ON banks;
CREATE TRIGGER banks_updated_at
  BEFORE UPDATE ON banks
  FOR EACH ROW
  EXECUTE FUNCTION update_banks_updated_at();

-- Enable RLS on banks
ALTER TABLE banks ENABLE ROW LEVEL SECURITY;
```

Key design decisions:
- `type` is 'personal' or 'business' (per CONTEXT.md, personal auto-created, business explicit)
- `cross_bank_default` controls copy vs move behavior (default: copy_only per spec)
- UUID primary key for consistency with existing schema
  </action>
  <verify>
- Migration file exists at specified path
- SQL syntax is valid (can run `supabase db reset` or lint)
  </verify>
  <done>
- banks table definition complete with all constraints
- Indexes and triggers defined
- RLS enabled (policies in Task 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bank_memberships table and RLS policies</name>
  <files>supabase/migrations/20260131000002_create_banks_tables.sql</files>
  <action>
Append to the same migration file:

```sql
-- BankMembership: Links users to banks with roles
CREATE TABLE IF NOT EXISTS bank_memberships (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bank_id UUID NOT NULL REFERENCES banks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('bank_owner', 'bank_admin', 'bank_member')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(bank_id, user_id)
);

-- Indexes for bank_memberships
CREATE INDEX IF NOT EXISTS idx_bank_memberships_bank_id ON bank_memberships(bank_id);
CREATE INDEX IF NOT EXISTS idx_bank_memberships_user_id ON bank_memberships(user_id);
CREATE INDEX IF NOT EXISTS idx_bank_memberships_role ON bank_memberships(role);

-- Enable RLS on bank_memberships
ALTER TABLE bank_memberships ENABLE ROW LEVEL SECURITY;

-- SECURITY DEFINER helper to check bank membership (prevents RLS recursion)
CREATE OR REPLACE FUNCTION is_bank_member(p_bank_id UUID, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM bank_memberships
    WHERE bank_id = p_bank_id AND user_id = p_user_id
  )
$$;

-- SECURITY DEFINER helper to check bank admin/owner
CREATE OR REPLACE FUNCTION is_bank_admin_or_owner(p_bank_id UUID, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM bank_memberships
    WHERE bank_id = p_bank_id 
      AND user_id = p_user_id
      AND role IN ('bank_owner', 'bank_admin')
  )
$$;

-- RLS Policies for banks
CREATE POLICY "Users can view banks they belong to"
  ON banks FOR SELECT
  USING (is_bank_member(id, auth.uid()));

CREATE POLICY "Bank owners/admins can update their banks"
  ON banks FOR UPDATE
  USING (is_bank_admin_or_owner(id, auth.uid()));

CREATE POLICY "Any user can create a bank"
  ON banks FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Bank owners can delete their banks"
  ON banks FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM bank_memberships
      WHERE bank_memberships.bank_id = banks.id
        AND bank_memberships.user_id = auth.uid()
        AND bank_memberships.role = 'bank_owner'
    )
  );

-- RLS Policies for bank_memberships
CREATE POLICY "Users can view memberships in their banks"
  ON bank_memberships FOR SELECT
  USING (is_bank_member(bank_id, auth.uid()));

CREATE POLICY "Bank admins/owners can manage memberships"
  ON bank_memberships FOR INSERT
  WITH CHECK (is_bank_admin_or_owner(bank_id, auth.uid()));

CREATE POLICY "Bank admins/owners can update memberships"
  ON bank_memberships FOR UPDATE
  USING (is_bank_admin_or_owner(bank_id, auth.uid()));

CREATE POLICY "Bank admins/owners can remove members"
  ON bank_memberships FOR DELETE
  USING (is_bank_admin_or_owner(bank_id, auth.uid()));

-- Allow users to create their own membership (for initial bank creation)
CREATE POLICY "Users can create their own initial membership"
  ON bank_memberships FOR INSERT
  WITH CHECK (user_id = auth.uid());
```

Key RLS patterns:
- SECURITY DEFINER functions prevent recursion in membership checks
- Bank owners have full control, admins have almost full control
- Members can only view, not modify bank settings
- Initial membership creation allowed for bank creator
  </action>
  <verify>
- Run `supabase db push` to apply migration
- Test: Create bank, verify user can see it
- Test: Another user cannot see the bank
- Query `SELECT * FROM pg_policies WHERE tablename IN ('banks', 'bank_memberships')` shows 8+ policies
  </verify>
  <done>
- bank_memberships table complete with FK constraints
- All indexes created
- SECURITY DEFINER helper functions created
- All RLS policies applied to both tables
- Migration runs without errors
  </done>
</task>

</tasks>

<verification>
1. `supabase db push` succeeds
2. Both tables exist: `SELECT tablename FROM pg_tables WHERE tablename IN ('banks', 'bank_memberships')`
3. RLS is enabled on both tables
4. Helper functions exist: `is_bank_member`, `is_bank_admin_or_owner`
5. Policies exist for SELECT, INSERT, UPDATE, DELETE on both tables
</verification>

<success_criteria>
- banks table with proper constraints and type enum
- bank_memberships table with user-bank relationship
- SECURITY DEFINER helpers prevent RLS recursion
- RLS policies enforce bank isolation
- Migration applies cleanly to local database
</success_criteria>

<output>
After completion, create `.planning/phases/09-bank-vault-architecture/09-02-SUMMARY.md`
</output>
