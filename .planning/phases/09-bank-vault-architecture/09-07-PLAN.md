---
phase: 09-bank-vault-architecture
plan: 07
type: execute
wave: 2
depends_on: ["09-02", "09-03"]
files_modified:
  - src/stores/bankContextStore.ts
  - src/hooks/useBankContext.ts
  - src/types/bank.ts
autonomous: true

must_haves:
  truths:
    - "bankContextStore tracks activeBankId and activeVaultId"
    - "useBankContext hook provides bank/vault data and switching"
    - "Cross-tab sync works via localStorage"
  artifacts:
    - path: "src/stores/bankContextStore.ts"
      provides: "Zustand store for bank/vault context"
      contains: "useBankContextStore"
    - path: "src/hooks/useBankContext.ts"
      provides: "Hook for bank/vault data fetching and switching"
      contains: "useBankContext"
    - path: "src/types/bank.ts"
      provides: "TypeScript types for Bank/Vault model"
      contains: "interface Bank"
  key_links:
    - from: "bankContextStore"
      to: "localStorage"
      via: "cross-tab sync"
      pattern: "BANK_CONTEXT_UPDATED_KEY"
    - from: "useBankContext"
      to: "bankContextStore"
      via: "state management"
      pattern: "useBankContextStore"
---

<objective>
Create the bank context store and hook to replace teamContextStore. This provides client-side state management for the active bank and vault context.

Purpose: Enable bank/vault switching in the UI while maintaining consistency with the existing teamContextStore patterns (cross-tab sync, initialization).
Output: Zustand store + React hook for bank/vault context, fully typed.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-bank-vault-architecture/09-CONTEXT.md
@.planning/phases/09-bank-vault-architecture/09-RESEARCH.md
@src/stores/teamContextStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bank types and bankContextStore</name>
  <files>
    src/types/bank.ts
    src/stores/bankContextStore.ts
  </files>
  <action>
Create bank types following existing patterns:

```typescript
// src/types/bank.ts
export type BankType = 'personal' | 'business'
export type BankRole = 'bank_owner' | 'bank_admin' | 'bank_member'
export type VaultType = 'personal' | 'team' | 'coach' | 'community' | 'client'
export type VaultRole = 'vault_owner' | 'vault_admin' | 'manager' | 'member' | 'guest'
export type FolderVisibility = 'all_members' | 'managers_only' | 'owner_only'

export interface Bank {
  id: string
  name: string
  type: BankType
  cross_bank_default: 'copy_only' | 'copy_and_remove'
  created_at: string
  updated_at: string
}

export interface BankMembership {
  id: string
  bank_id: string
  user_id: string
  role: BankRole
  created_at: string
}

export interface Vault {
  id: string
  bank_id: string
  name: string
  vault_type: VaultType
  default_sharelink_ttl_days: number
  created_at: string
  updated_at: string
}

export interface VaultMembership {
  id: string
  vault_id: string
  user_id: string
  role: VaultRole
  created_at: string
}

export interface BankWithMembership extends Bank {
  membership: BankMembership
  vaults?: Vault[]
}

export interface VaultWithMembership extends Vault {
  membership: VaultMembership
}
```

Create store following teamContextStore pattern:

```typescript
// src/stores/bankContextStore.ts
import { create } from 'zustand'

export const BANK_CONTEXT_UPDATED_KEY = 'bank-context-updated'

interface BankContextState {
  activeBankId: string | null
  activeVaultId: string | null
  isLoading: boolean
  isInitialized: boolean
  error: string | null

  setActiveBank: (bankId: string) => void
  setActiveVault: (vaultId: string | null) => void
  initialize: (bankId: string, vaultId: string | null) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  reset: () => void
}

export const useBankContextStore = create<BankContextState>((set) => ({
  activeBankId: null,
  activeVaultId: null,
  isLoading: true,
  isInitialized: false,
  error: null,

  setActiveBank: (bankId) => {
    set({ activeBankId: bankId, activeVaultId: null, error: null })
    // Trigger cross-tab sync
    if (typeof window !== 'undefined') {
      localStorage.setItem(BANK_CONTEXT_UPDATED_KEY, Date.now().toString())
    }
  },

  setActiveVault: (vaultId) => {
    set({ activeVaultId: vaultId, error: null })
    if (typeof window !== 'undefined') {
      localStorage.setItem(BANK_CONTEXT_UPDATED_KEY, Date.now().toString())
    }
  },

  initialize: (bankId, vaultId) => {
    set({
      activeBankId: bankId,
      activeVaultId: vaultId,
      isLoading: false,
      isInitialized: true,
      error: null,
    })
  },

  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error, isLoading: false }),
  reset: () =>
    set({
      activeBankId: null,
      activeVaultId: null,
      isLoading: true,
      isInitialized: false,
      error: null,
    }),
}))
```

Key patterns from teamContextStore:
- Cross-tab sync via localStorage event
- isInitialized flag for loading state
- Error handling
- Reset for logout
  </action>
  <verify>
- Files exist at correct paths
- TypeScript compiles without errors
- Store exports useBankContextStore
  </verify>
  <done>
- Bank/Vault types defined
- bankContextStore matches teamContextStore patterns
- Cross-tab sync via BANK_CONTEXT_UPDATED_KEY
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useBankContext hook</name>
  <files>src/hooks/useBankContext.ts</files>
  <action>
Create hook following existing patterns (useTeamContext):

```typescript
// src/hooks/useBankContext.ts
import { useEffect, useCallback } from 'react'
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase-client'
import { useAuth } from '@/hooks/useAuth'
import { useBankContextStore, BANK_CONTEXT_UPDATED_KEY } from '@/stores/bankContextStore'
import type { Bank, BankWithMembership, Vault, VaultWithMembership } from '@/types/bank'

const QUERY_KEY = 'bankContext'

export function useBankContext() {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const {
    activeBankId,
    activeVaultId,
    isLoading: storeLoading,
    isInitialized,
    error,
    setActiveBank,
    setActiveVault,
    initialize,
    setLoading,
    setError,
    reset,
  } = useBankContextStore()

  // Fetch user's banks with memberships
  const { data: banks, isLoading: banksLoading } = useQuery({
    queryKey: [QUERY_KEY, 'banks', user?.id],
    queryFn: async (): Promise<BankWithMembership[]> => {
      if (!user) return []

      const { data: memberships, error } = await supabase
        .from('bank_memberships')
        .select(`
          id,
          role,
          created_at,
          bank:banks (
            id,
            name,
            type,
            cross_bank_default,
            created_at,
            updated_at
          )
        `)
        .eq('user_id', user.id)

      if (error) throw error

      return memberships.map((m) => ({
        ...m.bank,
        membership: {
          id: m.id,
          bank_id: m.bank.id,
          user_id: user.id,
          role: m.role,
          created_at: m.created_at,
        },
      })) as BankWithMembership[]
    },
    enabled: !!user,
    staleTime: 5 * 60 * 1000, // 5 minutes
  })

  // Fetch vaults for active bank
  const { data: vaults, isLoading: vaultsLoading } = useQuery({
    queryKey: [QUERY_KEY, 'vaults', activeBankId, user?.id],
    queryFn: async (): Promise<VaultWithMembership[]> => {
      if (!user || !activeBankId) return []

      const { data: memberships, error } = await supabase
        .from('vault_memberships')
        .select(`
          id,
          role,
          created_at,
          vault:vaults (
            id,
            bank_id,
            name,
            vault_type,
            default_sharelink_ttl_days,
            created_at,
            updated_at
          )
        `)
        .eq('user_id', user.id)
        .eq('vault.bank_id', activeBankId)

      if (error) throw error

      return memberships
        .filter((m) => m.vault) // Filter out null vaults
        .map((m) => ({
          ...m.vault,
          membership: {
            id: m.id,
            vault_id: m.vault.id,
            user_id: user.id,
            role: m.role,
            created_at: m.created_at,
          },
        })) as VaultWithMembership[]
    },
    enabled: !!user && !!activeBankId,
    staleTime: 5 * 60 * 1000,
  })

  // Initialize on first load
  useEffect(() => {
    if (!user || banksLoading || isInitialized) return

    if (banks && banks.length > 0) {
      // Find personal bank or use first bank
      const personalBank = banks.find((b) => b.type === 'personal')
      const defaultBank = personalBank || banks[0]

      initialize(defaultBank.id, null)
    } else {
      setError('No banks found for user')
    }
  }, [user, banks, banksLoading, isInitialized, initialize, setError])

  // Cross-tab sync
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === BANK_CONTEXT_UPDATED_KEY) {
        queryClient.invalidateQueries({ queryKey: [QUERY_KEY] })
      }
    }

    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [queryClient])

  // Get active bank object
  const activeBank = banks?.find((b) => b.id === activeBankId) || null
  
  // Get active vault object
  const activeVault = vaults?.find((v) => v.id === activeVaultId) || null

  // Get personal vault in active bank
  const personalVault = vaults?.find((v) => v.vault_type === 'personal') || null

  const switchBank = useCallback(
    (bankId: string) => {
      setActiveBank(bankId)
    },
    [setActiveBank]
  )

  const switchVault = useCallback(
    (vaultId: string | null) => {
      setActiveVault(vaultId)
    },
    [setActiveVault]
  )

  return {
    // State
    activeBankId,
    activeVaultId,
    activeBank,
    activeVault,
    personalVault,
    banks: banks || [],
    vaults: vaults || [],
    
    // Loading
    isLoading: storeLoading || banksLoading || vaultsLoading,
    isInitialized,
    error,

    // Actions
    switchBank,
    switchVault,
    reset,
    
    // Helpers
    isPersonalBank: activeBank?.type === 'personal',
    isBusinessBank: activeBank?.type === 'business',
    bankRole: activeBank?.membership.role || null,
    vaultRole: activeVault?.membership.role || null,
  }
}
```

Key features:
- Fetches banks and vaults with memberships
- Auto-selects personal bank on init
- Cross-tab sync via storage event
- Provides role info for permission checks
- Matches useTeamContext API
  </action>
  <verify>
- TypeScript compiles without errors
- Hook exports useBankContext
- Test: Import hook, verify it returns expected shape
  </verify>
  <done>
- useBankContext hook created
- Fetches banks and vaults from DB
- Auto-initializes to personal bank
- Cross-tab sync implemented
- Returns all needed state and actions
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Types are properly defined
3. Store and hook export correctly
4. Hook returns expected shape (activeBankId, banks, vaults, switchBank, etc.)
</verification>

<success_criteria>
- Bank/Vault types match database schema
- bankContextStore follows teamContextStore patterns
- useBankContext hook works with Tanstack Query
- Cross-tab sync works via localStorage
- Auto-selects personal bank on initialization
</success_criteria>

<output>
After completion, create `.planning/phases/09-bank-vault-architecture/09-07-SUMMARY.md`
</output>
