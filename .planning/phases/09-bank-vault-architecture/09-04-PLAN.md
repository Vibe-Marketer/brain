---
phase: 09-bank-vault-architecture
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260131000004_create_recordings_tables.sql
autonomous: true

must_haves:
  truths:
    - "recordings table exists with bank_id, owner_user_id, and call metadata"
    - "vault_entries table exists to link recordings to vaults with local context"
    - "RLS policies enforce recording access through bank membership"
  artifacts:
    - path: "supabase/migrations/20260131000004_create_recordings_tables.sql"
      provides: "Recordings and VaultEntries tables with RLS"
      contains: "CREATE TABLE recordings"
  key_links:
    - from: "recordings"
      to: "banks"
      via: "FK bank_id"
      pattern: "REFERENCES banks\\(id\\)"
    - from: "vault_entries"
      to: "recordings"
      via: "FK recording_id"
      pattern: "REFERENCES recordings\\(id\\)"
    - from: "vault_entries"
      to: "vaults"
      via: "FK vault_id"
      pattern: "REFERENCES vaults\\(id\\)"
---

<objective>
Create the recordings and vault_entries tables with proper constraints and RLS policies. Recordings are the base call objects that live in exactly one bank. VaultEntries enable recordings to appear in multiple vaults with different local context.

Purpose: This is the core data model - recordings contain the actual call data, vault_entries provide the many-to-many relationship between recordings and vaults with local metadata.
Output: Two tables (recordings, vault_entries) with complete RLS policies and migration tracking fields.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-bank-vault-architecture/09-CONTEXT.md
@.planning/phases/09-bank-vault-architecture/09-RESEARCH.md
@docs/planning/CallVault-Final-Spaces.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recordings table with migration tracking</name>
  <files>supabase/migrations/20260131000004_create_recordings_tables.sql</files>
  <action>
Create migration file with the recordings table:

```sql
-- Recordings: Base call objects containing audio/transcript
-- Lives in exactly ONE bank - cross-bank movement is always COPY
CREATE TABLE IF NOT EXISTS recordings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  legacy_recording_id BIGINT, -- For migration from fathom_calls
  bank_id UUID NOT NULL REFERENCES banks(id) ON DELETE CASCADE,
  owner_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Call metadata (migrated from fathom_calls)
  title TEXT NOT NULL,
  audio_url TEXT,
  video_url TEXT,
  full_transcript TEXT,
  summary TEXT,
  
  -- Tags at recording level (source-level, global)
  global_tags TEXT[] DEFAULT '{}',
  
  -- Source tracking
  source_app TEXT, -- 'fathom', 'google_meet', 'zoom', 'youtube'
  source_metadata JSONB DEFAULT '{}',
  
  -- Timing
  duration INTEGER, -- seconds
  recording_start_time TIMESTAMPTZ,
  recording_end_time TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  synced_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Prevent duplicate migrations within same bank
  UNIQUE(bank_id, legacy_recording_id)
);

-- Indexes for recordings
CREATE INDEX IF NOT EXISTS idx_recordings_bank_id ON recordings(bank_id);
CREATE INDEX IF NOT EXISTS idx_recordings_owner_user_id ON recordings(owner_user_id);
CREATE INDEX IF NOT EXISTS idx_recordings_legacy_recording_id ON recordings(legacy_recording_id);
CREATE INDEX IF NOT EXISTS idx_recordings_source_app ON recordings(source_app);
CREATE INDEX IF NOT EXISTS idx_recordings_created_at ON recordings(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_recordings_global_tags ON recordings USING GIN(global_tags);

-- Full-text search on transcript (matches existing pattern)
CREATE INDEX IF NOT EXISTS idx_recordings_transcript_fts 
  ON recordings USING GIN(to_tsvector('english', COALESCE(full_transcript, '')));

-- Updated_at trigger
CREATE OR REPLACE FUNCTION update_recordings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS recordings_updated_at ON recordings;
CREATE TRIGGER recordings_updated_at
  BEFORE UPDATE ON recordings
  FOR EACH ROW
  EXECUTE FUNCTION update_recordings_updated_at();

-- Enable RLS on recordings
ALTER TABLE recordings ENABLE ROW LEVEL SECURITY;
```

Key design decisions:
- legacy_recording_id tracks source from fathom_calls migration
- global_tags are at recording level (source tags)
- UNIQUE(bank_id, legacy_recording_id) prevents duplicate migrations
- GIN indexes for tags and full-text search (matching existing patterns)
  </action>
  <verify>
- Migration file exists
- SQL syntax is valid
- Indexes match access patterns from existing fathom_calls queries
  </verify>
  <done>
- recordings table with all metadata fields from fathom_calls
- Migration tracking via legacy_recording_id
- Indexes for common query patterns
- RLS enabled
  </done>
</task>

<task type="auto">
  <name>Task 2: Create vault_entries table and RLS policies</name>
  <files>supabase/migrations/20260131000004_create_recordings_tables.sql</files>
  <action>
Append to the same migration file:

```sql
-- VaultEntry: Recording in Vault with local context
-- Same recording can appear in multiple vaults (within same bank) with different metadata
CREATE TABLE IF NOT EXISTS vault_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  vault_id UUID NOT NULL REFERENCES vaults(id) ON DELETE CASCADE,
  recording_id UUID NOT NULL REFERENCES recordings(id) ON DELETE CASCADE,
  folder_id UUID REFERENCES folders(id) ON DELETE SET NULL, -- Uses existing folders table
  
  -- Local context (vault-specific)
  local_tags TEXT[] DEFAULT '{}',
  scores JSONB, -- AI scoring results
  notes TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Same recording can only appear once per vault
  UNIQUE(vault_id, recording_id)
);

-- Indexes for vault_entries
CREATE INDEX IF NOT EXISTS idx_vault_entries_vault_id ON vault_entries(vault_id);
CREATE INDEX IF NOT EXISTS idx_vault_entries_recording_id ON vault_entries(recording_id);
CREATE INDEX IF NOT EXISTS idx_vault_entries_folder_id ON vault_entries(folder_id);
CREATE INDEX IF NOT EXISTS idx_vault_entries_local_tags ON vault_entries USING GIN(local_tags);
CREATE INDEX IF NOT EXISTS idx_vault_entries_created_at ON vault_entries(created_at DESC);

-- Updated_at trigger
CREATE OR REPLACE FUNCTION update_vault_entries_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS vault_entries_updated_at ON vault_entries;
CREATE TRIGGER vault_entries_updated_at
  BEFORE UPDATE ON vault_entries
  FOR EACH ROW
  EXECUTE FUNCTION update_vault_entries_updated_at();

-- Enable RLS on vault_entries
ALTER TABLE vault_entries ENABLE ROW LEVEL SECURITY;

-- SECURITY DEFINER helper to get recording's bank_id
CREATE OR REPLACE FUNCTION get_recording_bank_id(p_recording_id UUID)
RETURNS UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT bank_id FROM recordings WHERE id = p_recording_id
$$;

-- RLS Policies for recordings
-- Users can view recordings in banks they belong to
CREATE POLICY "Users can view recordings in their banks"
  ON recordings FOR SELECT
  USING (is_bank_member(bank_id, auth.uid()));

-- Recording owner can update their recordings
CREATE POLICY "Recording owners can update their recordings"
  ON recordings FOR UPDATE
  USING (owner_user_id = auth.uid());

-- Bank members can create recordings
CREATE POLICY "Bank members can create recordings"
  ON recordings FOR INSERT
  WITH CHECK (is_bank_member(bank_id, auth.uid()) AND owner_user_id = auth.uid());

-- Recording owner can delete if no vault_entries exist
-- (Enforced at application level - recordings with entries cannot be deleted)
CREATE POLICY "Recording owners can delete their recordings"
  ON recordings FOR DELETE
  USING (
    owner_user_id = auth.uid()
    AND NOT EXISTS (
      SELECT 1 FROM vault_entries WHERE vault_entries.recording_id = recordings.id
    )
  );

-- RLS Policies for vault_entries
-- Users can view entries in vaults they belong to
CREATE POLICY "Users can view vault entries in their vaults"
  ON vault_entries FOR SELECT
  USING (is_vault_member(vault_id, auth.uid()));

-- Bank admins can see all entries in bank's vaults
CREATE POLICY "Bank admins can view all vault entries"
  ON vault_entries FOR SELECT
  USING (
    is_bank_admin_or_owner(get_vault_bank_id(vault_id), auth.uid())
  );

-- Vault members with manager+ role can create entries
CREATE POLICY "Vault managers can create entries"
  ON vault_entries FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM vault_memberships
      WHERE vault_memberships.vault_id = vault_entries.vault_id
        AND vault_memberships.user_id = auth.uid()
        AND vault_memberships.role IN ('vault_owner', 'vault_admin', 'manager', 'member')
    )
  );

-- Vault admins/owners can update entries
CREATE POLICY "Vault admins can update entries"
  ON vault_entries FOR UPDATE
  USING (is_vault_admin_or_owner(vault_id, auth.uid()));

-- Members can update their own entries (entries they created)
CREATE POLICY "Members can update own entries"
  ON vault_entries FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM vault_memberships
      WHERE vault_memberships.vault_id = vault_entries.vault_id
        AND vault_memberships.user_id = auth.uid()
        AND vault_memberships.role IN ('member', 'manager')
    )
    AND EXISTS (
      SELECT 1 FROM recordings 
      WHERE recordings.id = vault_entries.recording_id
        AND recordings.owner_user_id = auth.uid()
    )
  );

-- Vault admins can delete entries
CREATE POLICY "Vault admins can delete entries"
  ON vault_entries FOR DELETE
  USING (is_vault_admin_or_owner(vault_id, auth.uid()));
```

Key patterns:
- vault_entries references existing folders table (add vault_id later in migration plan)
- local_tags are vault-specific, global_tags are recording-level
- UNIQUE(vault_id, recording_id) enforces one entry per vault
- Recording deletion blocked if vault_entries exist (per spec)
  </action>
  <verify>
- Run `supabase db push` to apply migration
- Verify recordings and vault_entries tables exist
- Verify RLS policies are correct
- Test: Create recording, create vault_entry, verify visible in vault
  </verify>
  <done>
- vault_entries table with local context fields
- All indexes for common query patterns
- SECURITY DEFINER helpers for cross-table checks
- RLS policies enforce vault membership for access
- Recording deletion blocked when entries exist
- Migration applies cleanly
  </done>
</task>

</tasks>

<verification>
1. `supabase db push` succeeds
2. Both tables exist: `SELECT tablename FROM pg_tables WHERE tablename IN ('recordings', 'vault_entries')`
3. RLS is enabled on both tables
4. Indexes exist for all FK columns and common query patterns
5. UNIQUE constraints prevent duplicate entries
6. **TEAM-06 Cross-member visibility test:**
   - User A shares recording to vault (creates vault_entry)
   - User B (vault member) can see the vault_entry via SELECT
   - User C (non-member) cannot see it
   - SQL test: `SELECT COUNT(*) FROM vault_entries WHERE vault_id = '<test-vault>' AND auth.uid() = '<user-b>'` returns 1
</verification>

<success_criteria>
- recordings table with all fathom_calls-equivalent fields
- legacy_recording_id for migration tracking
- vault_entries table with local context (tags, scores, notes)
- UNIQUE(vault_id, recording_id) prevents duplicates
- Recording deletion blocked when entries exist
- RLS policies enforce bank/vault isolation
- Full-text search index on transcript
</success_criteria>

<output>
After completion, create `.planning/phases/09-bank-vault-architecture/09-04-SUMMARY.md`
</output>
