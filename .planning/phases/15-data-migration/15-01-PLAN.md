---
phase: 15-data-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260227000001_fix_migration_function.sql
autonomous: true

must_haves:
  truths:
    - "Production data is profiled — NULL rates, orphan counts, row counts per user are known before migration runs"
    - "migrate_fathom_call_to_recording() applies COALESCE defaults for NULL title, duration, tags, and source_platform"
    - "migrate_fathom_call_to_recording() injects external_id into source_metadata for every Fathom row"
    - "Batch migration runs to completion — get_migration_progress() shows 100%"
    - "Automated verification confirms: zero unmigrated non-orphan rows, external_id present on all migrated rows, random spot-check titles match"
    - "RLS verification confirms User A cannot read User B's recordings using real JWT (not service_role)"
  artifacts:
    - path: "supabase/migrations/20260227000001_fix_migration_function.sql"
      provides: "Updated migration function with COALESCE defaults and external_id injection"
      contains: "COALESCE"
  key_links:
    - from: "migrate_fathom_call_to_recording()"
      to: "recordings table"
      via: "INSERT with COALESCE defaults and external_id in source_metadata"
      pattern: "COALESCE.*Untitled Call"
    - from: "migrate-recordings edge function"
      to: "migrate_batch_fathom_calls()"
      via: "RPC call with batch_size=100"
      pattern: "migrate_batch_fathom_calls"
---

<objective>
Profile production data, fix the migration function (COALESCE defaults + external_id), run the batch migration to completion, and verify with automated SQL + RLS checks.

Purpose: This is the core data migration work. DATA-01 (batch migration), DATA-02 (RLS verification), DATA-03 (source_metadata normalization), and DATA-05 (dry-run profiling) are all addressed here. The migration function has two known gaps that must be fixed before running: no COALESCE for NULL titles (fails NOT NULL constraint), and no external_id in source_metadata (breaks Phase 17 dedup).

Output: All fathom_calls rows migrated to recordings table. Verified via automated SQL. RLS isolation verified with real JWTs.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-data-migration/15-CONTEXT.md
@.planning/phases/15-data-migration/15-RESEARCH.md

# Migration infrastructure files (already deployed in v1 brain repo)
@supabase/migrations/20260131000007_create_recordings_tables.sql
@supabase/migrations/20260131000008_migration_function.sql
@supabase/functions/migrate-recordings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Profile production data and deploy fixed migration function</name>
  <files>supabase/migrations/20260227000001_fix_migration_function.sql</files>
  <action>
Step 1 — Profile production data (DATA-05 dry-run). Run these read-only diagnostic queries via the Supabase SQL Editor (use `npx supabase db execute` or the Dashboard SQL Editor against the production project vltmrnjsubfzrgrtdqey):

```sql
-- NULL rate profiling
SELECT
  COUNT(*) AS total_rows,
  COUNT(*) FILTER (WHERE user_id IS NULL) AS null_user_id,
  COUNT(*) FILTER (WHERE title IS NULL) AS null_title,
  COUNT(*) FILTER (WHERE full_transcript IS NULL) AS null_transcript,
  COUNT(*) FILTER (WHERE recording_start_time IS NULL) AS null_start_time,
  COUNT(*) FILTER (WHERE source_platform IS NULL) AS null_source_platform,
  COUNT(DISTINCT user_id) AS distinct_users,
  MIN(created_at) AS oldest_call,
  MAX(created_at) AS newest_call
FROM fathom_calls;

-- Row counts per user
SELECT user_id, COUNT(*) AS call_count
FROM fathom_calls GROUP BY user_id ORDER BY call_count DESC LIMIT 20;

-- Orphaned rows (no auth.users entry)
SELECT COUNT(*) AS orphaned_count
FROM fathom_calls fc
WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = fc.user_id);

-- Current migration progress
SELECT * FROM get_migration_progress();
```

Log the profiling results in the SUMMARY. Per CONTEXT locked decision: orphaned rows will be skipped and logged (they belong to deleted accounts). This is expected.

Step 2 — Create the updated migration function SQL file. Write `supabase/migrations/20260227000001_fix_migration_function.sql` that uses `CREATE OR REPLACE FUNCTION migrate_fathom_call_to_recording(...)` to:

1. Apply COALESCE defaults per CONTEXT locked decision:
   - `COALESCE(NULLIF(TRIM(v_call.title), ''), 'Untitled Call')` for title
   - `COALESCE(EXTRACT(EPOCH FROM (v_call.recording_end_time - v_call.recording_start_time))::INTEGER, 0)` for duration
   - `COALESCE(v_call.auto_tags, '{}')` for global_tags
   - `COALESCE(v_call.source_platform, 'fathom')` for source_app

2. Add `external_id` to source_metadata: `'external_id', v_call.recording_id::TEXT` as the first key in `jsonb_build_object(...)`. This is the Phase 17 dedup key.

3. Preserve ALL existing behavior: bank/vault lookup, personal bank creation, vault_entry creation, `ON CONFLICT DO NOTHING` idempotency, `RETURNING id` pattern.

Read the existing migration function at `supabase/migrations/20260131000008_migration_function.sql` FIRST to understand the exact current implementation. The updated function must be a drop-in replacement — same signature, same SECURITY DEFINER, same SET search_path.

Step 3 — Deploy the updated function to production. Run the migration SQL via `npx supabase db push` or execute it directly in the Supabase SQL Editor. Verify the function was replaced by checking its definition:

```sql
SELECT prosrc FROM pg_proc WHERE proname = 'migrate_fathom_call_to_recording' LIMIT 1;
```

Confirm the output contains 'Untitled Call' (COALESCE default) and 'external_id' (source_metadata key).
  </action>
  <verify>
1. Profiling queries executed without errors and results documented
2. Migration SQL file exists at supabase/migrations/20260227000001_fix_migration_function.sql
3. Function deployed: `SELECT prosrc FROM pg_proc WHERE proname = 'migrate_fathom_call_to_recording'` contains 'Untitled Call' and 'external_id'
  </verify>
  <done>Production data is profiled (NULL rates, orphan count, row counts known). Updated migration function is deployed with COALESCE defaults and external_id injection. Ready to run the batch.</done>
</task>

<task type="auto">
  <name>Task 2: Run batch migration and verify with automated SQL + RLS checks</name>
  <files></files>
  <action>
Step 1 — Run the batch migration to completion. Use a shell loop to call the migrate-recordings edge function repeatedly until `complete: true`. The edge function requires an admin user's JWT.

To get the admin JWT: either (a) use the Supabase Dashboard to copy a token from the API settings, or (b) get a fresh JWT by signing in and extracting from the browser. The migrate-recordings function checks `user_roles` for `role = 'ADMIN'` — verify this exists first:

```sql
SELECT * FROM user_roles WHERE role = 'ADMIN';
```

If no ADMIN role exists for the developer's user_id, insert one:

```sql
INSERT INTO user_roles (user_id, role) VALUES ('<USER_ID>', 'ADMIN') ON CONFLICT DO NOTHING;
```

Then run the migration loop:

```bash
SUPABASE_URL="https://vltmrnjsubfzrgrtdqey.supabase.co"
ADMIN_JWT="<paste admin JWT here>"

while true; do
  RESPONSE=$(curl -s -X POST \
    "$SUPABASE_URL/functions/v1/migrate-recordings" \
    -H "Authorization: Bearer $ADMIN_JWT" \
    -H "Content-Type: application/json")

  echo "$RESPONSE" | python3 -c "
import sys, json
d = json.load(sys.stdin)
o = d.get('overall', {})
print(f\"Migrated: {o.get('migrated', '?')}/{o.get('total_calls', '?')} ({o.get('remaining', '?')} remaining)\")" 2>/dev/null || echo "$RESPONSE"

  COMPLETE=$(echo "$RESPONSE" | python3 -c "
import sys, json
d = json.load(sys.stdin)
print(str(d.get('overall', {}).get('complete', False)))" 2>/dev/null)

  if [ "$COMPLETE" = "True" ] || [ "$COMPLETE" = "true" ]; then
    echo "Migration complete!"
    break
  fi

  sleep 2
done
```

IMPORTANT per CONTEXT locked decision: Run from a SINGLE terminal session. Do NOT run from multiple tabs (race condition risk for personal bank creation). The batch function handles skip-and-continue via EXCEPTION WHEN OTHERS — failed rows are logged via RAISE WARNING and the batch continues.

Step 2 — Run automated verification queries (DATA-01 + DATA-02 + DATA-03):

```sql
-- 1. Count match: unmigrated non-orphan rows (must be 0)
SELECT COUNT(*) AS unmigrated_non_orphans
FROM fathom_calls fc
WHERE NOT EXISTS (
  SELECT 1 FROM recordings r WHERE r.legacy_recording_id = fc.recording_id
) AND EXISTS (
  SELECT 1 FROM auth.users u WHERE u.id = fc.user_id
);

-- 2. Random spot-check: 10 migrated rows (titles should match or show 'Untitled Call')
SELECT
  fc.recording_id,
  fc.title AS old_title,
  r.title AS new_title,
  fc.created_at AS old_date,
  r.recording_start_time AS new_date,
  (COALESCE(NULLIF(TRIM(fc.title), ''), 'Untitled Call') = r.title) AS title_match
FROM fathom_calls fc
JOIN recordings r ON r.legacy_recording_id = fc.recording_id
ORDER BY RANDOM() LIMIT 10;

-- 3. source_metadata has external_id for all migrated rows (must be 0)
SELECT COUNT(*) AS missing_external_id
FROM recordings
WHERE legacy_recording_id IS NOT NULL
  AND (source_metadata->>'external_id') IS NULL;

-- 4. Bank membership integrity: no migrated recordings without bank membership
SELECT r.owner_user_id, COUNT(*) AS recording_count
FROM recordings r
WHERE r.legacy_recording_id IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM bank_memberships bm
    WHERE bm.bank_id = r.bank_id AND bm.user_id = r.owner_user_id
  )
GROUP BY r.owner_user_id;

-- 5. Overall progress (should show 100%)
SELECT * FROM get_migration_progress();
```

Step 3 — RLS verification (DATA-02). Use Supabase User Impersonation in the Dashboard SQL Editor:

1. Click the user selector at the top of the SQL Editor
2. Select User A (the developer's account) and run: `SELECT COUNT(*) FROM recordings;` — note the count
3. If a second test user exists, switch to User B and run: `SELECT COUNT(*) FROM recordings WHERE owner_user_id = '<User_A_UUID>';` — must return 0
4. As User B, run: `SELECT COUNT(*) FROM vault_entries ve JOIN recordings r ON r.id = ve.recording_id WHERE r.owner_user_id = '<User_A_UUID>';` — must return 0

If no second test user exists per CONTEXT locked decision ("Create a second test user account for cross-tenant RLS verification"), create one:
- In Supabase Dashboard > Authentication > Users > Add user (email: test-rls@callvault-test.local, auto-confirm)
- The new user will have zero recordings, so querying as them should return 0 rows for all tables
- This confirms RLS works for users with no data

If the SQL Editor user impersonation is unavailable, use the manual SET LOCAL approach:

```sql
SET LOCAL ROLE authenticated;
SET LOCAL request.jwt.claims = '{"role":"authenticated","sub":"<USER_B_UUID>"}';
SELECT COUNT(*) FROM recordings WHERE owner_user_id = '<USER_A_UUID>';
-- Must return 0
```

Document ALL verification results in the SUMMARY.
  </action>
  <verify>
1. Migration loop completed with `complete: true`
2. `unmigrated_non_orphans` query returns 0
3. `missing_external_id` query returns 0
4. Bank membership integrity query returns 0 rows
5. RLS verification: User B cannot see User A's recordings (count = 0)
6. `get_migration_progress()` shows 100%
  </verify>
  <done>Batch migration is 100% complete. All non-orphan fathom_calls rows exist in recordings with correct COALESCE defaults and external_id in source_metadata. RLS isolation verified with real JWTs — cross-tenant data leakage is zero. DATA-01, DATA-02, DATA-03, DATA-05 requirements satisfied.</done>
</task>

</tasks>

<verification>
- `SELECT * FROM get_migration_progress()` shows total_calls = migrated (100% or close, minus orphans)
- `SELECT COUNT(*) FROM recordings WHERE legacy_recording_id IS NOT NULL AND (source_metadata->>'external_id') IS NULL` returns 0
- RLS cross-tenant test returns 0 rows for foreign user's data
- Profiling results documented in SUMMARY
</verification>

<success_criteria>
1. Every non-orphaned fathom_calls row has a corresponding recordings row (unmigrated_non_orphans = 0)
2. All migrated recordings have external_id in source_metadata (missing_external_id = 0)
3. NULL titles became 'Untitled Call', NULL durations became 0
4. User A cannot query User B's recordings (RLS verified with real JWT, not service_role)
5. get_migration_progress() reports 100% complete
</success_criteria>

<output>
After completion, create `.planning/phases/15-data-migration/15-01-SUMMARY.md`
</output>
