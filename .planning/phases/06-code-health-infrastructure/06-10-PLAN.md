---
phase: 06-code-health-infrastructure
plan: 10
type: execute
wave: 3
depends_on: ["06-05", "06-06", "06-07", "06-08", "06-09"]
files_modified:
  - supabase/functions/automation-webhook/index.ts
  - supabase/functions/automation-email/index.ts
  - supabase/functions/_shared/rate-limiter.ts
  - supabase/migrations/YYYYMMDDHHMMSS_rate_limits_table.sql
autonomous: true

must_haves:
  truths:
    - "Rate limiting persists across cold starts"
    - "Rate limits stored in database, not in-memory"
    - "Admin can configure rate limit thresholds"
  artifacts:
    - path: "supabase/functions/_shared/rate-limiter.ts"
      provides: "Database-backed rate limiting"
      min_lines: 80
    - path: "supabase/migrations/YYYYMMDDHHMMSS_rate_limits_table.sql"
      provides: "Rate limits table schema"
      min_lines: 20
  key_links:
    - from: "supabase/functions/automation-webhook/index.ts"
      to: "supabase/functions/_shared/rate-limiter.ts"
      via: "import"
      pattern: "import.*rate-limiter"
---

<objective>
Move rate limiting to database for cold start persistence

Purpose: In-memory rate limits reset on cold starts, need database persistence (INFRA-03)
Output: Production-hardened rate limiting with sliding windows and configurable thresholds
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-code-health-infrastructure/06-CONTEXT.md
@supabase/functions/automation-webhook/index.ts
@supabase/functions/automation-email/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limits database table</name>
  <files>
    supabase/migrations/YYYYMMDDHHMMSS_rate_limits_table.sql
  </files>
  <action>
1. Create migration file with proper naming:
   - Format: `YYYYMMDDHHMMSS_create_rate_limits_table.sql`
   - Example: `20260131120000_create_rate_limits_table.sql`

2. Design schema for rate limiting:
```sql
-- Migration: Create rate_limits table for persistent rate limiting
-- Purpose: Store rate limit state that survives Edge Function cold starts

CREATE TABLE IF NOT EXISTS rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  resource_type VARCHAR(50) NOT NULL,  -- 'webhook', 'email', 'chat', etc.
  window_start TIMESTAMPTZ NOT NULL,
  window_duration_ms INTEGER NOT NULL DEFAULT 60000,  -- 1 minute default
  request_count INTEGER NOT NULL DEFAULT 0,
  max_requests INTEGER NOT NULL DEFAULT 100,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, resource_type)
);

-- Index for fast lookups
CREATE INDEX idx_rate_limits_user_resource ON rate_limits(user_id, resource_type);
CREATE INDEX idx_rate_limits_window ON rate_limits(window_start);

-- RLS
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;

-- Service role can manage rate limits
CREATE POLICY "Service role manages rate limits"
  ON rate_limits FOR ALL
  USING (true)
  WITH CHECK (true);
```

3. Add rate limit configuration table:
```sql
CREATE TABLE IF NOT EXISTS rate_limit_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  resource_type VARCHAR(50) NOT NULL UNIQUE,
  max_requests INTEGER NOT NULL,
  window_duration_ms INTEGER NOT NULL,
  is_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Default configurations
INSERT INTO rate_limit_configs (resource_type, max_requests, window_duration_ms) VALUES
  ('webhook', 100, 60000),      -- 100/minute
  ('email', 95, 86400000),      -- 95/day (Resend free tier buffer)
  ('chat', 50, 60000);          -- 50/minute
```
  </action>
  <verify>
    - Migration file exists with proper naming
    - Tables have proper indexes and RLS
    - Default configs inserted
  </verify>
  <done>
    Database schema created for persistent rate limiting
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database-backed rate limiter</name>
  <files>
    supabase/functions/_shared/rate-limiter.ts
  </files>
  <action>
1. Create `supabase/functions/_shared/rate-limiter.ts`:

```typescript
import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number;  // Unix timestamp in ms
  limit: number;
}

interface RateLimitConfig {
  resourceType: string;
  maxRequests?: number;
  windowDurationMs?: number;
}

export async function checkRateLimit(
  supabase: SupabaseClient,
  userId: string,
  config: RateLimitConfig
): Promise<RateLimitResult> {
  const { resourceType, maxRequests, windowDurationMs } = config;
  const now = Date.now();

  // 1. Get config from database (or use defaults)
  const { data: dbConfig } = await supabase
    .from('rate_limit_configs')
    .select('max_requests, window_duration_ms, is_enabled')
    .eq('resource_type', resourceType)
    .single();

  const limit = maxRequests ?? dbConfig?.max_requests ?? 100;
  const windowMs = windowDurationMs ?? dbConfig?.window_duration_ms ?? 60000;
  const isEnabled = dbConfig?.is_enabled ?? true;

  if (!isEnabled) {
    return { allowed: true, remaining: limit, resetAt: now + windowMs, limit };
  }

  // 2. Upsert rate limit entry with atomic increment
  const { data: entry, error } = await supabase.rpc('check_and_increment_rate_limit', {
    p_user_id: userId,
    p_resource_type: resourceType,
    p_max_requests: limit,
    p_window_duration_ms: windowMs,
    p_current_time: new Date(now).toISOString()
  });

  if (error) {
    console.error('Rate limit check failed:', error);
    // Fail open - allow request if rate limiter errors
    return { allowed: true, remaining: limit, resetAt: now + windowMs, limit };
  }

  return {
    allowed: entry.allowed,
    remaining: entry.remaining,
    resetAt: entry.reset_at,
    limit
  };
}
```

2. Add database function for atomic rate limit check:
   - Add to migration file
   - Uses upsert + conditional logic for atomic increment
   - Handles window expiry

3. Add sliding window support:
   - Track requests in current window
   - Reset count when window expires
   - Calculate remaining correctly
  </action>
  <verify>
    - rate-limiter.ts exports checkRateLimit function
    - Uses database for state persistence
    - Handles errors gracefully (fail open)
  </verify>
  <done>
    Database-backed rate limiter with sliding windows created
  </done>
</task>

<task type="auto">
  <name>Task 3: Update automation functions to use database rate limiter</name>
  <files>
    supabase/functions/automation-webhook/index.ts
    supabase/functions/automation-email/index.ts
  </files>
  <action>
1. Update automation-webhook/index.ts:
   - Remove in-memory rateLimitMap
   - Remove checkRateLimit local function
   - Import from _shared/rate-limiter
   - Update call sites to use async version

```typescript
// Before
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();
function checkRateLimit(userId: string) { ... }

// After
import { checkRateLimit } from '../_shared/rate-limiter.ts';

// In handler:
const rateLimit = await checkRateLimit(supabase, userId, { resourceType: 'webhook' });
```

2. Update automation-email/index.ts:
   - Same pattern as webhook
   - Remove rateLimitTracker Map
   - Import and use shared rate limiter

3. Preserve response headers:
   - X-RateLimit-Limit
   - X-RateLimit-Remaining
   - X-RateLimit-Reset
   - Retry-After (on 429)

4. Test migration path:
   - New rate limits start fresh (old in-memory state lost anyway on cold start)
   - No backward compatibility issues
  </action>
  <verify>
    - No in-memory rate limit maps in either file
    - Both import from _shared/rate-limiter
    - Rate limit headers still returned
    - 429 still returned when limit exceeded
  </verify>
  <done>
    Both automation functions use database-backed rate limiting
  </done>
</task>

</tasks>

<verification>
1. Migration creates rate_limits and rate_limit_configs tables
2. rate-limiter.ts uses database for state
3. automation-webhook uses shared rate limiter
4. automation-email uses shared rate limiter
5. Rate limits survive function cold starts
6. Rate limit headers returned correctly
</verification>

<success_criteria>
- Database tables created for rate limits
- Shared rate limiter module created
- Both automation functions migrated to database-backed limiting
- In-memory Maps removed
- Rate limits persist across cold starts
- Admin can configure limits via rate_limit_configs table
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-health-infrastructure/06-10-SUMMARY.md`
</output>
