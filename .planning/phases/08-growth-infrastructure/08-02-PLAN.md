---
phase: 08-growth-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - supabase/functions/polar-webhook/index.ts
  - supabase/functions/polar-checkout/index.ts
  - supabase/functions/polar-create-customer/index.ts
  - supabase/functions/polar-customer-state/index.ts
autonomous: true

must_haves:
  truths:
    - "Polar webhook events update user subscription status in database"
    - "Users can generate checkout URLs for plan upgrades"
    - "Polar customers are created for new users"
    - "Customer state can be fetched on-demand to verify subscription"
  artifacts:
    - path: "supabase/functions/polar-webhook/index.ts"
      provides: "Webhook handler for subscription events"
      contains: "validateEvent"
    - path: "supabase/functions/polar-checkout/index.ts"
      provides: "Checkout URL generation"
      exports: ["POST handler"]
    - path: "supabase/functions/polar-create-customer/index.ts"
      provides: "Customer creation at signup"
      contains: "polar.customers.create"
    - path: "supabase/functions/polar-customer-state/index.ts"
      provides: "On-demand state verification"
      contains: "getStateExternal"
  key_links:
    - from: "supabase/functions/polar-webhook/index.ts"
      to: "user_profiles"
      via: "subscription status update"
      pattern: "update.*subscription_status"
    - from: "all polar functions"
      to: "_shared/polar-client.ts"
      via: "getPolarClient import"
      pattern: "import.*getPolarClient"
---

<objective>
Create Polar Edge Functions for complete subscription lifecycle management.

Purpose: Enable 3-tier billing with real-time webhook updates and on-demand state verification.
Output: 4 Edge Functions handling webhooks, checkout, customer creation, and state sync.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-growth-infrastructure/08-CONTEXT.md
@.planning/phases/08-growth-infrastructure/08-RESEARCH.md
@.planning/phases/08-growth-infrastructure/08-01-SUMMARY.md
@supabase/CLAUDE.md
@supabase/functions/_shared/polar-client.ts
@supabase/functions/_shared/cors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create polar-webhook Edge Function</name>
  <files>supabase/functions/polar-webhook/index.ts</files>
  <action>
Create webhook handler following Edge Function conventions from supabase/CLAUDE.md.

Import webhook validation from SDK:
```typescript
import { validateEvent, WebhookVerificationError } from 'npm:@polar-sh/sdk/webhooks';
```

Handle these webhook events (from CONTEXT.md):
- subscription.created - Create subscription record
- subscription.active - Mark subscription active
- subscription.canceled - Mark canceled (user keeps access until period end)
- subscription.revoked - Immediate access loss (clear subscription fields)
- customer.created - Store polar_customer_id
- customer.state_changed - Trigger state sync

For each subscription event, update user_profiles:
- subscription_id
- subscription_status
- product_id  
- current_period_end

Use service role key to bypass RLS. Log events for debugging.

Validate webhook signature using POLAR_WEBHOOK_SECRET env var.
Return 200 OK on success, 403 on invalid signature, 500 on processing error.
  </action>
  <verify>
`ls supabase/functions/polar-webhook/index.ts` exists
File contains: validateEvent, WebhookVerificationError, subscription handlers
  </verify>
  <done>
Webhook handler processes all 6 event types, validates signatures, updates user_profiles with subscription state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create polar-checkout and polar-create-customer functions</name>
  <files>
supabase/functions/polar-checkout/index.ts
supabase/functions/polar-create-customer/index.ts
  </files>
  <action>
**polar-checkout/index.ts:**
Create checkout URL generation endpoint.

Accept POST with body: { productId: string } (e.g., 'solo-monthly', 'team-annual')
Require auth (JWT from header).
Use polar.checkouts.create() to generate checkout URL with:
- productId
- successUrl: configured base URL + /settings?tab=billing
- customerExternalId: user.id (links to existing Polar customer)

Return { checkoutUrl: string }

**polar-create-customer/index.ts:**
Create Polar customer for new users (called at signup or first billing access).

Require auth (JWT).
Check if user already has polar_customer_id in profile - if so, return existing.
Otherwise, create customer via polar.customers.create() with:
- email: user.email
- name: display_name or email prefix
- externalId: user.id
- organizationId: POLAR_ORG_ID

Store polar_customer_id and polar_external_id in user_profiles.
Return { customerId: string, created: boolean }

Both functions: Use getCorsHeaders(), follow auth patterns from supabase/CLAUDE.md.
  </action>
  <verify>
`ls supabase/functions/polar-checkout/index.ts` exists
`ls supabase/functions/polar-create-customer/index.ts` exists
Both files have CORS handling and JWT auth
  </verify>
  <done>
polar-checkout generates checkout URLs for any product. polar-create-customer creates customers with external ID linkage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create polar-customer-state function</name>
  <files>supabase/functions/polar-customer-state/index.ts</files>
  <action>
Create on-demand state verification endpoint.

This addresses the race condition pitfall from RESEARCH.md:
After checkout redirect, webhooks may not have arrived yet.
Call this function to immediately fetch and sync current state.

Require auth (JWT).
Use polar.customers.getStateExternal({ externalId: user.id }) to fetch state.

Response includes activeSubscriptions array - extract:
- subscription.id
- subscription.status
- subscription.productId
- subscription.currentPeriodEnd

If state differs from local DB, update user_profiles.

Return {
  subscriptionId: string | null,
  status: string | null,
  productId: string | null,
  periodEnd: string | null,
  synced: boolean  // true if DB was updated
}

This enables frontend to call after checkout success to immediately show correct plan.
  </action>
  <verify>
`ls supabase/functions/polar-customer-state/index.ts` exists
File contains: getStateExternal, comparison with local state
  </verify>
  <done>
Customer state function fetches Polar state, compares with local DB, syncs if different, returns current subscription info.
  </done>
</task>

</tasks>

<verification>
1. All 4 Edge Function directories created with index.ts files
2. polar-webhook validates signatures and handles all event types
3. polar-checkout generates URLs with success redirect
4. polar-create-customer links external ID properly
5. polar-customer-state syncs state differences
6. All functions use shared polar-client.ts
</verification>

<success_criteria>
- Complete Polar webhook event handling for subscription lifecycle
- Checkout URL generation for upgrades
- Customer creation with external ID linkage
- On-demand state sync to handle webhook delays
- All functions follow supabase/CLAUDE.md conventions
</success_criteria>

<output>
After completion, create `.planning/phases/08-growth-infrastructure/08-02-SUMMARY.md`
</output>
