---
phase: 03.1-compact-integration-ui
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - src/components/integrations/IntegrationConnectModal.tsx
  - src/components/integrations/ConnectedContent.tsx
  - src/components/integrations/IntegrationButtonGroup.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking a compact button opens a modal with connection/disconnection flow"
    - "Modal shows connect flow when disconnected (reuses InlineConnectionWizard)"
    - "Modal shows disconnect option and account info when connected"
    - "IntegrationButtonGroup displays all integrations in a horizontal row"
  artifacts:
    - path: "src/components/integrations/IntegrationConnectModal.tsx"
      provides: "Reusable modal for integration connect/disconnect"
      exports: ["IntegrationConnectModal"]
    - path: "src/components/integrations/ConnectedContent.tsx"
      provides: "Modal content for connected state"
      exports: ["ConnectedContent"]
    - path: "src/components/integrations/IntegrationButtonGroup.tsx"
      provides: "Horizontal row of compact integration buttons"
      exports: ["IntegrationButtonGroup"]
  key_links:
    - from: "src/components/integrations/IntegrationConnectModal.tsx"
      to: "src/components/sync/InlineConnectionWizard.tsx"
      via: "reuse for disconnect state"
      pattern: "InlineConnectionWizard"
    - from: "src/components/integrations/IntegrationConnectModal.tsx"
      to: "src/stores/integrationModalStore.ts"
      via: "useIntegrationModalStore hook"
      pattern: "useIntegrationModalStore"
    - from: "src/components/integrations/IntegrationButtonGroup.tsx"
      to: "src/components/integrations/CompactIntegrationButton.tsx"
      via: "maps integrations to buttons"
      pattern: "CompactIntegrationButton"
---

<objective>
Build the composite components: IntegrationConnectModal (reusable modal for connection flows) and IntegrationButtonGroup (horizontal row of compact buttons).

Purpose: The modal provides consistent connection/disconnection UX across Sync, Settings, and Onboarding. The button group composes multiple CompactIntegrationButtons for the Sync page header.

Output: Three new files in src/components/integrations/ that compose the primitives from Plan 01.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03.1-compact-integration-ui/03.1-CONTEXT.md
@.planning/phases/03.1-compact-integration-ui/03.1-RESEARCH.md
@.planning/phases/03.1-compact-integration-ui/03.1-01-SUMMARY.md

@src/stores/integrationModalStore.ts
@src/components/integrations/CompactIntegrationButton.tsx
@src/components/ui/dialog.tsx
@src/components/sync/InlineConnectionWizard.tsx
@src/hooks/useIntegrationSync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IntegrationConnectModal and ConnectedContent</name>
  <files>
src/components/integrations/IntegrationConnectModal.tsx
src/components/integrations/ConnectedContent.tsx
  </files>
  <action>
Create IntegrationConnectModal - a reusable modal that shows different content based on connection state.

**IntegrationConnectModal.tsx:**

Props interface:
```typescript
interface IntegrationConnectModalProps {
  onConnectionChange?: () => void;
}
```

Implementation:
1. Use `useIntegrationModalStore` to get `isOpen`, `platform`, `closeModal`
2. Use `useIntegrationSync` to get current integration state
3. If `!platform`, return null
4. Find the integration matching platform
5. Determine `isConnected` from integration data

Use Dialog from @/components/ui/dialog:
```tsx
<Dialog open={isOpen} onOpenChange={(open) => !open && closeModal()}>
  <DialogContent className="sm:max-w-md">
    {isConnected ? (
      <ConnectedContent
        platform={platform}
        email={integration?.email}
        lastSyncAt={integration?.lastSyncAt}
        onDisconnect={handleDisconnect}
        onClose={closeModal}
      />
    ) : (
      <InlineConnectionWizard
        platform={platform}
        onComplete={() => {
          onConnectionChange?.();
          closeModal();
        }}
        onCancel={closeModal}
        currentEmail={integration?.email}
      />
    )}
  </DialogContent>
</Dialog>
```

For `handleDisconnect`:
- For now, just show a toast "Disconnect not implemented yet" - the actual disconnect API can be added later
- Close the modal after showing toast

**ConnectedContent.tsx:**

Props interface:
```typescript
interface ConnectedContentProps {
  platform: IntegrationPlatform;
  email?: string;
  lastSyncAt?: string | null;
  onDisconnect: () => void;
  onClose: () => void;
}
```

Per CONTEXT.md connected modal shows:
- "Connected as user@email.com"
- Last synced timestamp
- Disconnect button
- "Manage in Settings" link

Implementation:
1. Use DialogHeader, DialogTitle, DialogDescription from @/components/ui/dialog
2. Show platform icon + "[Platform] Connected" title with RiCheckboxCircleLine (green)
3. Display email in a row: "Connected as" | email
4. Display last sync: "Last synced" | relative time (use formatDistanceToNow)
5. DialogFooter with two buttons:
   - "Manage in Settings" (variant="hollow") - navigates to /settings/integrations
   - "Disconnect" (variant="destructive") - calls onDisconnect

Use useNavigate from react-router-dom for Settings navigation.

Icons needed:
- RiCheckboxCircleLine (success indicator in title)
- RiTimeLine (last synced row)
- RiSettings3Line (Manage in Settings button)

Platform names map (same as in CompactIntegrationButton):
```typescript
const platformNames = {
  fathom: "Fathom",
  google_meet: "Google Meet",
  zoom: "Zoom",
};
```
  </action>
  <verify>
- Files exist at src/components/integrations/IntegrationConnectModal.tsx and ConnectedContent.tsx
- TypeScript compiles: `npx tsc --noEmit src/components/integrations/IntegrationConnectModal.tsx`
- Modal uses Dialog component from @/components/ui/dialog
- ConnectedContent renders platform name, email, and last synced
- Disconnect button is destructive variant
  </verify>
  <done>
IntegrationConnectModal created with:
- Connected state: shows ConnectedContent with account info and disconnect
- Disconnected state: shows InlineConnectionWizard for OAuth flow
- Uses integrationModalStore for state management
- Reusable across Sync, Settings, and Onboarding contexts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IntegrationButtonGroup</name>
  <files>src/components/integrations/IntegrationButtonGroup.tsx</files>
  <action>
Create IntegrationButtonGroup - a horizontal row of CompactIntegrationButtons for the Sync page header.

Per CONTEXT.md: "Inline with section header - 'Integrations' header with compact buttons next to it"

Props interface:
```typescript
interface IntegrationButtonGroupProps {
  onIntegrationChange?: () => void;
}
```

Implementation:
1. Use `useIntegrationSync` to get integrations list
2. Use `useIntegrationModalStore` to get `openModal`
3. Map over integrations and render CompactIntegrationButton for each
4. When button clicked, call `openModal(platform)`

Layout structure:
```tsx
<div className="flex items-center gap-3">
  <span className="text-sm font-medium text-ink-soft uppercase tracking-wide">
    Integrations
  </span>
  <div className="flex items-center gap-2">
    {integrations.map((integration) => (
      <CompactIntegrationButton
        key={integration.platform}
        platform={integration.platform}
        connected={integration.connected}
        email={integration.email}
        lastSyncAt={integration.lastSyncAt}
        onClick={() => openModal(integration.platform)}
      />
    ))}
  </div>
</div>
```

The gap-2 (8px) between buttons allows 6+ to fit comfortably in a row.

Also include loading state:
- If `isLoading` from useIntegrationSync is true, show skeleton or loading indicator
- Simple approach: just show nothing or a subtle spinner while loading
  </action>
  <verify>
- File exists at src/components/integrations/IntegrationButtonGroup.tsx
- TypeScript compiles: `npx tsc --noEmit src/components/integrations/IntegrationButtonGroup.tsx`
- Component maps useIntegrationSync results to CompactIntegrationButtons
- Uses integrationModalStore.openModal on button click
- Has "Integrations" label next to buttons
  </verify>
  <done>
IntegrationButtonGroup created with:
- "Integrations" label + horizontal row of compact buttons
- Uses useIntegrationSync for integration data
- Uses integrationModalStore to open modal on click
- Fits 6+ buttons with gap-2 spacing
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` succeeds with no TypeScript errors
2. All three components export correctly
3. Modal opens when button is clicked (can be verified by rendering IntegrationButtonGroup + IntegrationConnectModal together)
4. Connected modal shows account info and disconnect button
5. Disconnected modal shows InlineConnectionWizard
</verification>

<success_criteria>
1. IntegrationConnectModal.tsx exports IntegrationConnectModal component
2. ConnectedContent.tsx exports ConnectedContent component  
3. IntegrationButtonGroup.tsx exports IntegrationButtonGroup component
4. Modal conditionally renders connected/disconnected content based on integration state
5. Connected content shows email, last synced, disconnect button, settings link
6. Button group renders horizontal row of CompactIntegrationButtons
7. Clicking button triggers openModal with correct platform
8. Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-compact-integration-ui/03.1-02-SUMMARY.md`
</output>
