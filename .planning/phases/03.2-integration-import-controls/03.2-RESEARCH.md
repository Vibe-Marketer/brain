# Phase 3.2: Integration Import Controls - Research

**Researched:** 2026-01-28
**Domain:** React UI filter component with database persistence
**Confidence:** HIGH

## Summary

This phase adds a "Sources" filter control to the Sync page that allows users to toggle which connected integrations are included when viewing meetings. The research focused on existing codebase patterns for filter components, database persistence strategies, and the integration data flow.

The codebase already has well-established patterns for filter popovers (TagFilterPopover, FolderFilterPopover, etc.) that use Popover + content with checkboxes/toggles. The date filter (DateRangePicker) provides the button styling pattern to match. The Switch component from Radix UI is available and properly styled. The `user_settings` table is the established location for user preferences and already stores integration credentials.

**Primary recommendation:** Build a new SourcesFilterPopover component following existing filter popover patterns, using the Switch component for toggles, and persist state to a new column in user_settings table.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @radix-ui/react-popover | Already installed | Dropdown/popover primitive | Used by existing DateRangePicker, all filter popovers |
| @radix-ui/react-switch | Already installed | Toggle switch component | `Switch` component in `src/components/ui/switch.tsx` |
| Supabase | Already configured | Database persistence | `user_settings` table for user preferences |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| react-query | @tanstack/react-query | State management | Optimistic updates, cache invalidation |
| cn (lib/utils) | N/A | Class name merging | Conditional styling |
| Remix Icons | @remixicon/react | Icons | RiFilterLine for filter button |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Switch | Checkbox | Switch better matches "airplane mode" aesthetic per user decision |
| New table | user_settings column | Single source of truth for user preferences, simpler |
| localStorage | Database | Database ensures cross-device persistence per requirement |

**Installation:**
```bash
# No new packages needed - all dependencies already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── components/
│   └── sync/
│       └── SourcesFilterPopover.tsx    # New filter component
├── hooks/
│   └── useSyncSourceFilter.ts          # New hook for filter state
└── types/
    └── (update existing as needed)
```

### Pattern 1: Filter Popover Component
**What:** Self-contained popover with trigger button and content dropdown
**When to use:** All filter controls in the app
**Example:**
```typescript
// Source: Existing pattern from TagFilterPopover.tsx
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { FilterButton } from "./FilterButton";

export function SourcesFilterPopover({
  enabledSources,
  connectedIntegrations,
  onSourceToggle,
}: SourcesFilterPopoverProps) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <FilterButton
          icon={<SourceIcons />}
          label="Sources"
          count={enabledSources.length}
          active={enabledSources.length < connectedIntegrations.length}
        />
      </PopoverTrigger>
      <PopoverContent className="w-64 p-0" align="start">
        {/* Toggle rows */}
      </PopoverContent>
    </Popover>
  );
}
```

### Pattern 2: Database Persistence via user_settings
**What:** Store user preferences in the `user_settings` table with upsert pattern
**When to use:** Any persistent user preference that should survive sessions
**Example:**
```typescript
// Source: Existing pattern from useSyncTabState.ts, useSetupWizard.ts
const saveSourceFilter = async (enabledPlatforms: string[]) => {
  const { user } = await getSafeUser();
  if (!user) return;

  await supabase
    .from("user_settings")
    .upsert({
      user_id: user.id,
      sync_source_filter: enabledPlatforms, // New column
    }, { onConflict: "user_id" });
};
```

### Pattern 3: Immediate Client-Side Filtering
**What:** Filter meetings array in-memory without refetching from database
**When to use:** When the full dataset is already loaded
**Example:**
```typescript
// Source: Existing pattern in SyncTab.tsx filteredExistingTranscripts
const filteredMeetings = existingTranscripts.filter(transcript => {
  const platform = transcript.source_platform || 'fathom';
  return enabledSources.includes(platform);
});
```

### Pattern 4: Button with Integration Icons
**What:** Display small circular integration icons in the filter button
**When to use:** Visual indicator of which sources are enabled
**Example:**
```typescript
// Source: SourcePlatformIcons.tsx, CompactIntegrationButton.tsx
// Use size={14} for small circular icons matching transcript table
<div className="flex items-center -space-x-1">
  {enabledSources.map(platform => {
    const Icon = platformIcons[platform];
    return <Icon key={platform} size={14} className="rounded-full" />;
  })}
</div>
```

### Anti-Patterns to Avoid
- **Refetching on filter change:** Don't call `loadExistingTranscripts()` when toggle changes - filter client-side
- **Separate preferences table:** Don't create a new table - use existing `user_settings`
- **Storing in localStorage:** Don't use localStorage - database ensures cross-device sync
- **Allowing zero sources:** Never allow all sources to be disabled - keep last one enabled

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Toggle switch | Custom checkbox with styling | `Switch` from `@/components/ui/switch` | Already styled with focus states, dark mode |
| Popover positioning | Manual absolute positioning | Radix `Popover` | Handles edge cases, focus trapping |
| Integration icons | Inline SVGs | `FathomIcon`, `GoogleMeetIcon`, `ZoomIcon` from SourcePlatformIcons | Consistent sizing, already created |
| Filter button styling | Custom button | `FilterButton` component | Matches existing filter patterns |

**Key insight:** The codebase has established patterns for every piece of this feature. The implementation is primarily composition, not creation.

## Common Pitfalls

### Pitfall 1: Race Condition on Initial Load
**What goes wrong:** User sees all meetings briefly before filter is applied
**Why it happens:** Integrations load before saved filter preferences are fetched
**How to avoid:** Load filter preferences alongside integration status in `useIntegrationSync` or a combined hook
**Warning signs:** Flash of unfiltered content on page load

### Pitfall 2: Orphaned Filter State
**What goes wrong:** Filter includes a platform that user has disconnected
**Why it happens:** Filter stored in DB references platform no longer connected
**How to avoid:** On each load, intersect saved filter with currently connected platforms
**Warning signs:** Filter shows count that doesn't match visible integrations

### Pitfall 3: Preventing Last Toggle Disable
**What goes wrong:** User disables all toggles, sees empty results
**Why it happens:** No validation preventing the last toggle from being turned off
**How to avoid:** Check if toggle would result in zero enabled sources; if so, prevent and show toast
**Warning signs:** Empty meeting list with confusing state

### Pitfall 4: Dark Mode Icon Visibility
**What goes wrong:** Google Meet icon disappears on dark background (white circle on dark)
**Why it happens:** GoogleMeetIcon has white background without visible border in dark mode
**How to avoid:** Ensure icons have sufficient contrast or border in dark mode context
**Warning signs:** Missing icons in dropdown on dark mode

### Pitfall 5: Stale Filter After New Integration
**What goes wrong:** Newly connected integration doesn't appear in results
**Why it happens:** Filter persisted with old platforms, new one not in enabled list
**How to avoid:** When saving new integration connection, add it to enabled filter sources
**Warning signs:** User connects integration but can't see its meetings

## Code Examples

Verified patterns from official sources:

### Toggle Row in Dropdown
```typescript
// Source: Pattern from TagFilterPopover.tsx, adapted with Switch
<div className="space-y-1 p-2">
  {connectedIntegrations.map((integration) => {
    const Icon = platformIcons[integration.platform];
    const isEnabled = enabledSources.includes(integration.platform);
    const isLastEnabled = isEnabled && enabledSources.length === 1;

    return (
      <div
        key={integration.platform}
        className={cn(
          "flex items-center gap-3 px-3 py-2 rounded-md",
          !isEnabled && "opacity-50"
        )}
      >
        <Icon size={20} />
        <span className="flex-1 text-sm font-medium">
          {platformNames[integration.platform]}
        </span>
        <Switch
          checked={isEnabled}
          onCheckedChange={(checked) => {
            if (!checked && isLastEnabled) {
              toast.error("At least one source must be enabled");
              return;
            }
            onSourceToggle(integration.platform, checked);
          }}
        />
      </div>
    );
  })}
</div>
```

### Loading Saved Filter Preferences
```typescript
// Source: Pattern from useSyncTabState.ts
const loadFilterPreferences = useCallback(async () => {
  const { user, error } = await getSafeUser();
  if (error || !user) return;

  const { data: settings } = await supabase
    .from("user_settings")
    .select("sync_source_filter")
    .eq("user_id", user.id)
    .maybeSingle();

  if (settings?.sync_source_filter) {
    // Intersect with currently connected platforms
    const validSources = settings.sync_source_filter.filter(
      (platform: string) => connectedPlatforms.includes(platform)
    );
    setEnabledSources(validSources.length > 0 ? validSources : connectedPlatforms);
  } else {
    // Default: all connected platforms enabled
    setEnabledSources(connectedPlatforms);
  }
}, [connectedPlatforms]);
```

### Filter Button with Icons
```typescript
// Source: Pattern from FilterButton.tsx, DateRangePicker.tsx
<Button
  variant="default"
  size="sm"
  className={cn(
    "h-8 gap-1.5 text-xs",
    hasActiveFilter && "ring-2 ring-vibe-orange ring-offset-2"
  )}
>
  <span>Sources</span>
  <span className="text-[10px] bg-vibe-orange text-white rounded-full px-1.5 py-0.5">
    {enabledSources.length}
  </span>
  <div className="flex items-center -space-x-1 ml-1">
    {enabledSources.map(platform => {
      const Icon = platformIcons[platform];
      return <Icon key={platform} size={14} />;
    })}
  </div>
</Button>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| N/A - new feature | Database-persisted filter | Phase 3.2 | Filter state survives sessions |

**Deprecated/outdated:**
- None for this feature

## Open Questions

Things that couldn't be fully resolved:

1. **Database migration for new column**
   - What we know: Need to add `sync_source_filter` column to `user_settings` table
   - What's unclear: Exact column type (text[] vs jsonb)
   - Recommendation: Use `text[] DEFAULT NULL` for simplicity, NULL means "all enabled"

2. **Real-time subscription updates**
   - What we know: `useIntegrationSync` already subscribes to `user_settings` changes
   - What's unclear: Whether to extend that subscription or create separate filter hook
   - Recommendation: Create `useSyncSourceFilter` hook that loads preferences once and saves on change, avoid over-subscribing

## Sources

### Primary (HIGH confidence)
- `src/components/transcript-library/TagFilterPopover.tsx` - Filter popover pattern
- `src/components/ui/switch.tsx` - Toggle component
- `src/components/ui/date-range-picker.tsx` - Button styling pattern
- `src/hooks/useIntegrationSync.ts` - Integration status data source
- `src/components/transcript-library/SourcePlatformIcons.tsx` - Integration icons
- `src/components/transcripts/SyncTab.tsx` - Integration with date filter, filtering pattern

### Secondary (MEDIUM confidence)
- `src/integrations/supabase/types.ts` - user_settings schema (lines 1112-1198)

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All components already exist in codebase
- Architecture: HIGH - Patterns are well-established and documented in existing code
- Pitfalls: MEDIUM - Based on common React filter patterns and codebase analysis

**Research date:** 2026-01-28
**Valid until:** 60 days (stable patterns, no external dependencies)
