---
phase: 02-chat-foundation
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - supabase/functions/chat-stream-v2/index.ts
autonomous: true

must_haves:
  truths:
    - "All 14 RAG tools are defined with zod schemas and execute functions"
    - "Search tools (1-9) use the shared search pipeline module"
    - "Analytical tools (10-14) use direct Supabase queries"
    - "System prompt instructs query expansion (multiple diverse queries per search)"
    - "Tool results include recording_id for citation linking"
  artifacts:
    - path: "supabase/functions/chat-stream-v2/index.ts"
      provides: "Complete tool definitions for all 14 RAG tools"
      contains: "searchTranscriptsByQuery"
  key_links:
    - from: "supabase/functions/chat-stream-v2/index.ts"
      to: "supabase/functions/_shared/search-pipeline.ts"
      via: "import executeHybridSearch"
      pattern: "executeHybridSearch"
    - from: "supabase/functions/chat-stream-v2/index.ts"
      to: "hybrid_search_transcripts RPC"
      via: "shared search pipeline"
      pattern: "hybrid_search"
---

<objective>
Define all 14 RAG tools with AI SDK `tool()` + zod schemas, wire their execute functions to the shared search pipeline, and create the full system prompt with query expansion guidance. This transforms the PoC skeleton into a fully functional chat backend.

Purpose: CHAT-01 (all 14 tools firing consistently) and CHAT-05 (AI SDK migration) are the two largest requirements. This plan delivers both by converting the 14 OpenAI JSON-format tool definitions into AI SDK native tools with proper execute functions.
Output: Complete `chat-stream-v2/index.ts` with all 14 tools, system prompt, and query expansion.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-foundation/02-RESEARCH.md
@.planning/phases/02-chat-foundation/02-CONTEXT.md

# Source: Current 14 tool definitions + execute handlers to port
@supabase/functions/chat-stream/index.ts

# Dependencies from prior plans
@.planning/phases/02-chat-foundation/02-01-SUMMARY.md
@.planning/phases/02-chat-foundation/02-03-SUMMARY.md

# Shared modules created in plan 03
@supabase/functions/_shared/search-pipeline.ts
@supabase/functions/_shared/embeddings.ts

# ACQ AI reference for query expansion patterns
@docs/reference/technical-reverse-engineering-report-ACQai.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define all 14 tools with zod schemas and execute functions</name>
  <files>supabase/functions/chat-stream-v2/index.ts</files>
  <action>
Expand the PoC `chat-stream-v2/index.ts` to include all 14 RAG tools. Read the current tool definitions from `chat-stream/index.ts` (lines 236-634 for definitions, lines 646-1456 for execute handlers) and convert to AI SDK format.

**Import the shared search pipeline:**
```typescript
import { executeHybridSearch, diversityFilter } from '../_shared/search-pipeline.ts';
import { generateQueryEmbedding } from '../_shared/embeddings.ts';
```

**Tool categories and patterns:**

**Category A — Search Pipeline Tools (1-9):**
All share the same pattern: accept search parameters → call `executeHybridSearch()` → return results.

1. `searchTranscriptsByQuery` — `z.object({ query: z.string(), limit: z.number().optional() })` → executeHybridSearch with query
2. `searchBySpeaker` — `z.object({ query: z.string(), speaker: z.string(), limit: z.number().optional() })` → executeHybridSearch with speaker filter
3. `searchByDateRange` — `z.object({ query: z.string(), date_from: z.string().optional(), date_to: z.string().optional(), limit: z.number().optional() })` → executeHybridSearch with date filters
4. `searchByCategory` — `z.object({ query: z.string(), category: z.string(), limit: z.number().optional() })` → executeHybridSearch with category filter
5. `searchByIntentSignal` — `z.object({ query: z.string(), intent_type: z.enum(['buying_signal', 'objection', 'question', 'concern']), limit: z.number().optional() })` → filter by intent
6. `searchBySentiment` — `z.object({ query: z.string(), sentiment: z.enum(['positive', 'negative', 'neutral', 'mixed']), limit: z.number().optional() })` → filter by sentiment
7. `searchByTopics` — `z.object({ query: z.string(), topics: z.array(z.string()), limit: z.number().optional() })` → filter by topic tags
8. `searchByUserTags` — `z.object({ query: z.string(), tags: z.array(z.string()), limit: z.number().optional() })` → filter by user tags
9. `searchByEntity` — `z.object({ query: z.string(), entity_type: z.enum(['company', 'person', 'product']).optional(), entity_name: z.string(), limit: z.number().optional() })` → search + JSONB entity post-filter

**Category B — Analytical Tools (10-14):**
Direct Supabase queries, no search pipeline.

10. `getCallDetails` — Already in PoC. `z.object({ recording_id: z.string() })` → query fathom_calls table
11. `getCallsList` — `z.object({ limit: z.number().optional(), offset: z.number().optional(), category: z.string().optional(), date_from: z.string().optional(), date_to: z.string().optional() })` → paginated fathom_calls query
12. `getAvailableMetadata` — `z.object({ metadata_type: z.enum(['categories', 'speakers', 'tags', 'topics']) })` → distinct values query
13. `advancedSearch` — `z.object({ query: z.string().optional(), speaker: z.string().optional(), category: z.string().optional(), date_from: z.string().optional(), date_to: z.string().optional(), sentiment: z.string().optional(), intent: z.string().optional(), tags: z.array(z.string()).optional(), limit: z.number().optional() })` → combined filter search
14. `compareCalls` — `z.object({ recording_ids: z.array(z.string()).min(2).max(5) })` → fetch + format side-by-side

**For each tool's execute function:**
- Read the corresponding handler from `chat-stream/index.ts`
- Port the Supabase queries exactly (same table names, same RPC calls, same filters)
- Use closure access for: supabase client, user.id, openaiApiKey, hfApiKey, session filters
- Return structured results with `recording_id` in each result (critical for citations)
- Handle errors gracefully: catch and return `{ error: true, message: "..." }` instead of throwing

**For search tools (1-9):** Ensure each result includes:
- `recording_id` (for citation linking)
- `call_title`
- `call_date`
- `speaker`
- `text` (the transcript chunk)
- `relevance_score` (percentage)

**Do NOT:**
- Change the search pipeline algorithms
- Add new tools beyond the existing 14
- Skip any of the 14 tools (all must be ported)
  </action>
  <verify>
1. `grep -c "tool({" supabase/functions/chat-stream-v2/index.ts` returns 14
2. All 14 tool names present: `grep -o "search\w\+\|get\w\+\|advancedSearch\|compareCalls" supabase/functions/chat-stream-v2/index.ts | sort -u | wc -l` returns 14
3. Imports shared pipeline: `grep "search-pipeline\|embeddings" supabase/functions/chat-stream-v2/index.ts`
4. `supabase functions serve chat-stream-v2` starts without import errors
  </verify>
  <done>
- All 14 RAG tools defined with AI SDK tool() + zod inputSchema
- Search tools (1-9) use shared executeHybridSearch pipeline
- Analytical tools (10-14) use direct Supabase queries
- All execute functions return structured results with recording_id
- Error handling returns { error: true, message } not throws
  </done>
</task>

<task type="auto">
  <name>Task 2: Create full system prompt with query expansion guidance</name>
  <files>supabase/functions/chat-stream-v2/index.ts</files>
  <action>
Add the full system prompt to `chat-stream-v2/index.ts`. Port and enhance the existing system prompt from `chat-stream/index.ts` (found in the main handler section, ~lines 1650-1750).

**System prompt must include:**

1. **Identity:** "You are CallVault AI, an expert meeting intelligence assistant..."
2. **Tool catalog:** List all 14 tools with when to use each one. Group by use case:
   - "For general questions about call content: use searchTranscriptsByQuery"
   - "For speaker-specific questions: use searchBySpeaker"
   - "For time-based questions: use searchByDateRange"
   - etc.
3. **Query expansion guidance** (new, per ACQ AI reference):
   - "When answering a question, use MULTIPLE search tools with semantically diverse queries"
   - "For broad questions, fire 3-5 parallel searches with different query formulations"
   - "Example: 'What objections came up?' → searchTranscriptsByQuery('customer objections'), searchByIntentSignal('objections'), searchBySentiment('negative')"
   - "Prefer over-searching to under-searching — more tools = more comprehensive answers"
4. **Citation instructions:**
   - "Always cite your sources using [recording_id] markers when referencing specific calls"
   - "Include the recording_id from tool results so the UI can link back to the source call"
   - "If multiple results come from the same call, cite it once"
5. **Temporal context:** Include current date/time for relative date queries ("today", "last week", etc.)
6. **User filter context:** If request body includes filters (date range, speakers, categories, recording IDs), inject them into the prompt: "The user has active filters: [filters]. Respect these when searching."
7. **Error disclosure:** "If a tool fails or returns no results, acknowledge the gap: 'I couldn't find results for [X], but based on [Y]...'"

**Also add session filter injection:** Read filters from the request body and pass them to tool execute functions via closure. This ensures tools respect the user's active filters (date range, speaker, etc.).

**Port the message conversion:** Use `convertToModelMessages(messages)` for UIMessage → model message conversion. This replaces the manual `convertUIMessagesToOpenAI()` from the legacy function.

**Update the streamText() call** to use the full tool set and system prompt:
```typescript
const result = streamText({
  model: openrouter(selectedModel),
  system: systemPrompt,
  messages: await convertToModelMessages(messages),
  tools: allTools,
  toolChoice: 'auto',
  stopWhen: stepCountIs(5),
  onError: ({ error }) => console.error('[chat-stream-v2] Stream error:', error),
});
```
  </action>
  <verify>
1. System prompt includes all 14 tool descriptions: `grep -c "search\|getCall\|advanced\|compare" supabase/functions/chat-stream-v2/index.ts` shows significant matches
2. Query expansion guidance present: `grep -i "multiple\|diverse\|parallel" supabase/functions/chat-stream-v2/index.ts`
3. Citation instructions present: `grep -i "recording_id\|cite\|citation" supabase/functions/chat-stream-v2/index.ts`
4. `supabase functions serve chat-stream-v2` starts successfully
  </verify>
  <done>
- Full system prompt with all 14 tool descriptions
- Query expansion guidance encourages multiple diverse searches
- Citation instructions tell model to cite recording_ids
- Temporal context injected (current date/time)
- User filter context respected
- Message conversion using SDK's convertToModelMessages
- chat-stream-v2 is a complete, fully-functional replacement for chat-stream
  </done>
</task>

</tasks>

<verification>
- All 14 tools fire when relevant to test queries
- System prompt produces multi-tool responses (query expansion working)
- Tool results contain recording_id for citation linking
- `supabase functions serve chat-stream-v2` runs without errors
- streamText with all tools doesn't exceed Deno memory limits
</verification>

<success_criteria>
- 14/14 tools defined and functional (CHAT-01)
- AI SDK native tool() definitions replace OpenAI JSON format (CHAT-05)
- System prompt encourages query expansion (multiple tools per question)
- Tool results structured for citation support
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-foundation/02-05-SUMMARY.md`
</output>
