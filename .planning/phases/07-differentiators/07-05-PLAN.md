---
phase: 07-differentiators
plan: 05
type: execute
wave: 3
depends_on: ["07-04"]
files_modified:
  - supabase/migrations/20260131000004_create_notifications_table.sql
  - supabase/functions/check-client-health/index.ts
  - src/hooks/useHealthAlerts.ts
  - src/hooks/useNotifications.ts
  - src/components/notifications/NotificationBell.tsx
  - src/components/notifications/NotificationPanel.tsx
  - src/components/contacts/HealthAlertBanner.tsx
  - src/components/contacts/ReengagementEmailModal.tsx
autonomous: true

must_haves:
  truths:
    - "User receives email alert when tracked contact is overdue"
    - "User sees in-app notification for health alerts"
    - "User can click 'Send to chat' to generate re-engagement email"
    - "Health check cooldown prevents alert spam"
  artifacts:
    - path: "supabase/functions/check-client-health/index.ts"
      provides: "Scheduled health check Edge Function"
      exports: ["Deno.serve handler"]
    - path: "supabase/migrations/20260131000004_create_notifications_table.sql"
      provides: "user_notifications table"
      contains: "CREATE TABLE user_notifications"
    - path: "src/hooks/useNotifications.ts"
      provides: "useNotifications hook for in-app alerts"
      exports: ["useNotifications"]
  key_links:
    - from: "supabase/functions/check-client-health/index.ts"
      to: "supabase/functions/automation-email/index.ts"
      via: "function invocation"
      pattern: "invoke\\(['\"]automation-email"
    - from: "src/components/notifications/NotificationBell.tsx"
      to: "src/hooks/useNotifications.ts"
      via: "useNotifications hook"
      pattern: "useNotifications\\("
---

<objective>
Implement Client Health Alerts - engagement tracking with email and in-app notifications for overdue contacts.

Purpose: DIFF-03 enables users to monitor client engagement and receive alerts when clients haven't appeared in calls for a configurable period. "Send to chat" generates a personalized re-engagement email via AI.

Output: Scheduled health check function, notifications table and UI, email alerts via automation-email, re-engagement email generation modal.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-differentiators/07-RESEARCH.md
@.planning/phases/07-differentiators/07-CONTEXT.md

# Existing patterns to follow
@supabase/functions/automation-email/index.ts
@.planning/phases/07-differentiators/07-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifications table and health check function</name>
  <files>
    supabase/migrations/20260131000004_create_notifications_table.sql
    supabase/functions/check-client-health/index.ts
  </files>
  <action>
1. Create migration `20260131000004_create_notifications_table.sql`:
   ```sql
   -- ============================================================================
   -- TABLE: user_notifications
   -- ============================================================================
   -- In-app notifications for users
   
   CREATE TABLE user_notifications (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
     type TEXT NOT NULL,  -- 'health_alert', 'system', 'info'
     title TEXT NOT NULL,
     body TEXT,
     metadata JSONB,  -- { contact_id, days_since_seen, contact_name, etc. }
     read_at TIMESTAMPTZ,
     created_at TIMESTAMPTZ DEFAULT NOW()
   );
   
   -- Indexes
   CREATE INDEX idx_notifications_user ON user_notifications(user_id);
   CREATE INDEX idx_notifications_unread ON user_notifications(user_id, read_at) WHERE read_at IS NULL;
   
   -- RLS
   ALTER TABLE user_notifications ENABLE ROW LEVEL SECURITY;
   
   CREATE POLICY "Users can view their notifications"
     ON user_notifications FOR SELECT USING (auth.uid() = user_id);
   CREATE POLICY "Users can update their notifications"
     ON user_notifications FOR UPDATE USING (auth.uid() = user_id);
   CREATE POLICY "Service can insert notifications"
     ON user_notifications FOR INSERT WITH CHECK (true);  -- Service role only
   CREATE POLICY "Users can delete their notifications"
     ON user_notifications FOR DELETE USING (auth.uid() = user_id);
   
   COMMENT ON TABLE user_notifications IS 'In-app notifications including health alerts';
   ```

2. Create `supabase/functions/check-client-health/index.ts`:
   - Scheduled function (runs daily via pg_cron or Supabase scheduler)
   - For each user with tracked contacts:
     a. Get contacts where track_health = true
     b. Get user's default threshold from user_contact_settings
     c. For each contact, check: days since last_seen_at > threshold
     d. If overdue AND last_alerted_at is NULL or > 7 days ago (cooldown):
        - Create user_notification record
        - Optionally send email via automation-email function
        - Update contact.last_alerted_at

   Key implementation:
   ```typescript
   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
   import { getCorsHeaders } from '../_shared/cors.ts';
   
   Deno.serve(async (req) => {
     // CORS handling
     if (req.method === 'OPTIONS') {
       return new Response(null, { headers: getCorsHeaders(req) });
     }
     
     const supabase = createClient(
       Deno.env.get('SUPABASE_URL')!,
       Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
     );
     
     // Get all users with tracked contacts
     const { data: usersWithTracking } = await supabase
       .from('contacts')
       .select('user_id')
       .eq('track_health', true)
       .limit(1000);
     
     const uniqueUserIds = [...new Set(usersWithTracking?.map(c => c.user_id) || [])];
     
     for (const userId of uniqueUserIds) {
       // Get user settings
       const { data: settings } = await supabase
         .from('user_contact_settings')
         .select('default_health_threshold_days')
         .eq('user_id', userId)
         .maybeSingle();
       
       const defaultThreshold = settings?.default_health_threshold_days || 14;
       
       // Get tracked contacts
       const { data: contacts } = await supabase
         .from('contacts')
         .select('*')
         .eq('user_id', userId)
         .eq('track_health', true);
       
       for (const contact of contacts || []) {
         const threshold = contact.health_alert_threshold_days || defaultThreshold;
         const lastSeen = contact.last_seen_at ? new Date(contact.last_seen_at) : null;
         const daysSince = lastSeen 
           ? Math.floor((Date.now() - lastSeen.getTime()) / (1000 * 60 * 60 * 24))
           : Infinity;
         
         if (daysSince > threshold) {
           // Check cooldown (7 days since last alert)
           const lastAlerted = contact.last_alerted_at ? new Date(contact.last_alerted_at) : null;
           const daysSinceAlert = lastAlerted
             ? Math.floor((Date.now() - lastAlerted.getTime()) / (1000 * 60 * 60 * 24))
             : Infinity;
           
           if (daysSinceAlert >= 7) {
             // Create notification
             await supabase.from('user_notifications').insert({
               user_id: userId,
               type: 'health_alert',
               title: `${contact.name || contact.email} may need attention`,
               body: `It's been ${daysSince} days since your last call with this contact.`,
               metadata: {
                 contact_id: contact.id,
                 contact_name: contact.name,
                 contact_email: contact.email,
                 days_since_seen: daysSince,
               },
             });
             
             // Update last_alerted_at
             await supabase
               .from('contacts')
               .update({ last_alerted_at: new Date().toISOString() })
               .eq('id', contact.id);
             
             // Optionally send email (if user has email alerts enabled)
             // Use automation-email function
           }
         }
       }
     }
     
     return new Response(JSON.stringify({ success: true }), {
       headers: { ...getCorsHeaders(req), 'Content-Type': 'application/json' },
     });
   });
   ```

3. Set up scheduled invocation:
   - Add pg_cron job or Supabase scheduled function to run daily
   - Document setup steps for user in SUMMARY
  </action>
  <verify>
Deploy function: `supabase functions deploy check-client-health`
Test manually: Invoke function and verify notifications created for overdue contacts.
  </verify>
  <done>
Health check function creates notifications for overdue contacts with cooldown protection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notifications UI</name>
  <files>
    src/hooks/useNotifications.ts
    src/components/notifications/NotificationBell.tsx
    src/components/notifications/NotificationPanel.tsx
    src/lib/query-config.ts
  </files>
  <action>
1. Add query keys to `src/lib/query-config.ts`:
   ```typescript
   notifications: {
     all: ['notifications'] as const,
     list: () => ['notifications', 'list'] as const,
     unread: () => ['notifications', 'unread'] as const,
   },
   ```

2. Create `src/hooks/useNotifications.ts`:
   - Query user_notifications for current user
   - Return: notifications, unreadCount, markAsRead(id), markAllAsRead(), deleteNotification(id)
   - Use TanStack Query with optimistic updates

3. Create `src/components/notifications/NotificationBell.tsx`:
   - Bell icon in header (position near user avatar)
   - Unread count badge (red dot or number)
   - Click opens NotificationPanel popover

4. Create `src/components/notifications/NotificationPanel.tsx`:
   - Popover panel listing notifications
   - Each notification shows: title, body, time ago, unread indicator
   - Click notification marks as read
   - "Mark all as read" button
   - Health alerts show "Send to chat" action button
   - Empty state if no notifications
  </action>
  <verify>
1. Create test notification in database
2. Verify bell shows unread count
3. Click bell, verify panel opens with notification
4. Click notification, verify marked as read
  </verify>
  <done>
Notification bell and panel show in-app notifications with unread counts and mark-as-read functionality.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create re-engagement email generation</name>
  <files>
    src/components/contacts/HealthAlertBanner.tsx
    src/components/contacts/ReengagementEmailModal.tsx
    src/hooks/useHealthAlerts.ts
  </files>
  <action>
1. Create `src/hooks/useHealthAlerts.ts`:
   - `generateReengagementEmail(contactId)`: Calls AI to generate personalized email
   - Uses existing chat-stream or new dedicated endpoint
   - Default prompt (from CONTEXT.md): "Casual message noting they've been missed, recent call highlights, checking in"
   - Returns generated email text

2. Create `src/components/contacts/HealthAlertBanner.tsx`:
   - Displays in ContactCard when contact is overdue
   - Shows days since last seen
   - "Send Check-in" button opens ReengagementEmailModal

3. Create `src/components/contacts/ReengagementEmailModal.tsx`:
   - Modal with:
     - Contact name/email header
     - Editable prompt textarea (default prompt pre-filled)
     - "Generate Email" button
     - Generated email preview (editable)
     - "Copy to Clipboard" and "Open in Email Client" actions
   - Email generation via useHealthAlerts hook
   - Loading state during generation

4. Wire to NotificationPanel:
   - "Send to chat" on health alert notifications opens ReengagementEmailModal
   - Pass contact info from notification metadata
  </action>
  <verify>
1. Navigate to contact with overdue status
2. Click "Send Check-in" button
3. Verify modal opens with default prompt
4. Click "Generate Email"
5. Verify email is generated with personalized content
6. Edit prompt and regenerate to verify customization works
7. Copy to clipboard and verify content
  </verify>
  <done>
Re-engagement email generation works via AI prompt with customizable template. Users can generate, edit, and copy personalized check-in emails.
  </done>
</task>

</tasks>

<verification>
1. Notifications table created with proper RLS
2. check-client-health function runs and creates notifications
3. Notification bell shows unread count
4. Notification panel displays health alerts
5. "Send to chat" generates re-engagement email
6. Cooldown prevents duplicate alerts (7 day minimum)
7. Per-contact threshold overrides work
</verification>

<success_criteria>
- Tracked contacts generate health alerts when overdue
- In-app notifications appear with unread count
- Email alerts sent for overdue contacts (if enabled)
- "Send to chat" generates personalized re-engagement email
- Users can customize the prompt template
- Cooldown prevents alert spam
</success_criteria>

<output>
After completion, create `.planning/phases/07-differentiators/07-05-SUMMARY.md`
</output>
