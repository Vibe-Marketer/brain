---
phase: 10-chat-bank-vault-scoping
plan: 02
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - supabase/functions/chat-stream-v2/index.ts
  - supabase/functions/_shared/search-pipeline.ts
  - supabase/migrations/20260131300001_chat_vault_search_function.sql
autonomous: true

must_haves:
  truths:
    - "Chat searches only return VaultEntries in user's accessible vaults"
    - "Vault-selected mode: chat only sees VaultEntries in the selected vault"
    - "Bank-level mode (vault_id null): chat sees union of VaultEntries in vaults where user has VaultMembership"
    - "VaultMembership governs all access - BankMembership alone never exposes recordings"
  artifacts:
    - path: "supabase/migrations/20260131300001_chat_vault_search_function.sql"
      provides: "RPC function that joins fathom_transcripts to vault_entries for scoped search"
    - path: "supabase/functions/chat-stream-v2/index.ts"
      provides: "Search tools filter by bank/vault context"
    - path: "supabase/functions/_shared/search-pipeline.ts"
      provides: "SearchFilters extended with bank_id/vault_id"
  key_links:
    - from: "chat-stream-v2"
      to: "hybrid_search_transcripts_scoped"
      via: "supabase.rpc()"
      pattern: "filter by vault_entries.vault_id"
    - from: "vault_entries"
      to: "vault_memberships"
      via: "JOIN"
      pattern: "only return entries user has membership to"
---

<objective>
Implement bank/vault scoping for all chat search tools so searches only return content from vaults the user has access to.

Purpose: Close the integration gap where chat currently searches ALL user recordings instead of respecting Bank/Vault architecture.
Output: Chat searches are properly scoped to active bank/vault context.

CRITICAL ARCHITECTURE PRINCIPLE:
"All access (UI, search, chat, AI) is governed by VaultMembership; there is no hidden bypass."
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-chat-bank-vault-scoping/10-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vault-scoped search RPC function</name>
  <files>
    supabase/migrations/20260131300001_chat_vault_search_function.sql
  </files>
  <action>
Create a new migration that adds a vault-scoped search function:

```sql
-- Migration: Chat Vault-Scoped Search Function
-- Purpose: Extends hybrid_search_transcripts to respect bank/vault context
-- Phase: 10-chat-bank-vault-scoping

-- =============================================================================
-- VAULT-SCOPED HYBRID SEARCH
-- =============================================================================
-- This function wraps hybrid_search_transcripts with vault membership filtering.
-- 
-- Scoping logic:
-- 1. If vault_id provided: Only return chunks from recordings in that vault
-- 2. If only bank_id provided: Return chunks from all vaults user has membership in (within that bank)
-- 3. VaultMembership is the access primitive - BankMembership alone never exposes content

CREATE OR REPLACE FUNCTION hybrid_search_transcripts_scoped(
  query_text TEXT,
  query_embedding vector(1536),
  match_count INT,
  full_text_weight FLOAT,
  semantic_weight FLOAT,
  rrf_k INT,
  filter_user_id UUID,
  filter_bank_id UUID DEFAULT NULL,
  filter_vault_id UUID DEFAULT NULL,
  -- Original filters from hybrid_search_transcripts
  filter_date_start DATE DEFAULT NULL,
  filter_date_end DATE DEFAULT NULL,
  filter_speakers TEXT[] DEFAULT NULL,
  filter_categories TEXT[] DEFAULT NULL,
  filter_recording_ids INT[] DEFAULT NULL,
  filter_topics TEXT[] DEFAULT NULL,
  filter_sentiment TEXT DEFAULT NULL,
  filter_intent_signals TEXT[] DEFAULT NULL,
  filter_user_tags TEXT[] DEFAULT NULL
)
RETURNS TABLE (
  chunk_id TEXT,
  chunk_text TEXT,
  recording_id BIGINT,
  speaker_name TEXT,
  call_title TEXT,
  call_date TIMESTAMPTZ,
  call_category TEXT,
  topics TEXT[],
  sentiment TEXT,
  intent_signals TEXT[],
  user_tags TEXT[],
  entities JSONB,
  rrf_score FLOAT,
  similarity_score FLOAT,
  vault_id UUID,  -- NEW: Include vault_id in results for attribution
  vault_name TEXT -- NEW: Include vault name for result badges
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  accessible_vault_ids UUID[];
BEGIN
  -- Determine which vaults the user can access
  IF filter_vault_id IS NOT NULL THEN
    -- Specific vault requested - verify user has membership
    IF NOT EXISTS (
      SELECT 1 FROM vault_memberships 
      WHERE user_id = filter_user_id 
      AND vault_id = filter_vault_id
    ) THEN
      -- User doesn't have access to this vault - return empty
      RETURN;
    END IF;
    accessible_vault_ids := ARRAY[filter_vault_id];
  ELSIF filter_bank_id IS NOT NULL THEN
    -- Bank-level search - get all vaults user has membership in within this bank
    SELECT ARRAY_AGG(vm.vault_id) INTO accessible_vault_ids
    FROM vault_memberships vm
    JOIN vaults v ON v.id = vm.vault_id
    WHERE vm.user_id = filter_user_id
    AND v.bank_id = filter_bank_id;
    
    -- If user has no vault memberships in this bank, return empty
    IF accessible_vault_ids IS NULL OR array_length(accessible_vault_ids, 1) IS NULL THEN
      RETURN;
    END IF;
  ELSE
    -- No bank/vault specified - fall back to user's legacy data (pre-migration)
    -- This allows gradual migration without breaking existing functionality
    accessible_vault_ids := NULL; -- Will use filter_user_id only
  END IF;

  -- If we have vault scoping, filter recording_ids to those in accessible vaults
  -- This bridges the gap between new vault_entries and existing fathom_transcripts
  IF accessible_vault_ids IS NOT NULL THEN
    -- Get recording_ids that are in accessible vaults via vault_entries
    -- For now, bridge through legacy_recording_id until transcripts are migrated
    WITH scoped_recordings AS (
      SELECT DISTINCT r.legacy_recording_id
      FROM vault_entries ve
      JOIN recordings r ON r.id = ve.recording_id
      WHERE ve.vault_id = ANY(accessible_vault_ids)
      AND r.legacy_recording_id IS NOT NULL
    )
    SELECT ARRAY_AGG(legacy_recording_id::INT) INTO filter_recording_ids
    FROM scoped_recordings;
    
    -- If no recordings in accessible vaults, return empty
    IF filter_recording_ids IS NULL OR array_length(filter_recording_ids, 1) IS NULL THEN
      RETURN;
    END IF;
  END IF;

  -- Call the existing hybrid_search_transcripts with scoped recording_ids
  RETURN QUERY
  SELECT 
    hs.chunk_id,
    hs.chunk_text,
    hs.recording_id,
    hs.speaker_name,
    hs.call_title,
    hs.call_date,
    hs.call_category,
    hs.topics,
    hs.sentiment,
    hs.intent_signals,
    hs.user_tags,
    hs.entities,
    hs.rrf_score,
    hs.similarity_score,
    -- Lookup vault info for result attribution
    ve.vault_id,
    v.name as vault_name
  FROM hybrid_search_transcripts(
    query_text,
    query_embedding,
    match_count,
    full_text_weight,
    semantic_weight,
    rrf_k,
    filter_user_id,
    filter_date_start,
    filter_date_end,
    filter_speakers,
    filter_categories,
    filter_recording_ids,
    filter_topics,
    filter_sentiment,
    filter_intent_signals,
    filter_user_tags
  ) hs
  -- Left join to get vault attribution (may be null for pre-migration data)
  LEFT JOIN recordings r ON r.legacy_recording_id = hs.recording_id
  LEFT JOIN vault_entries ve ON ve.recording_id = r.id 
    AND (accessible_vault_ids IS NULL OR ve.vault_id = ANY(accessible_vault_ids))
  LEFT JOIN vaults v ON v.id = ve.vault_id;
  
END;
$$;

COMMENT ON FUNCTION hybrid_search_transcripts_scoped IS 
  'Vault-scoped wrapper for hybrid_search_transcripts. Filters results to vaults user has membership in.';
```
  </action>
  <verify>
- Migration applies without errors: `supabase db push`
- Function exists: `\df hybrid_search_transcripts_scoped` in psql
- Function signature includes filter_bank_id and filter_vault_id parameters
  </verify>
  <done>
- Vault-scoped search function created
- Migration applied successfully
- Function joins vault_entries to filter by membership
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SearchFilters type to include bank_id/vault_id</name>
  <files>
    supabase/functions/_shared/search-pipeline.ts
  </files>
  <action>
1. Update the SearchFilters interface:
```typescript
export interface SearchFilters {
  date_start?: string;
  date_end?: string;
  speakers?: string[];
  categories?: string[];
  topics?: string[];
  sentiment?: string;
  intent_signals?: string[];
  user_tags?: string[];
  recording_ids?: number[];
  // NEW: Bank/Vault scoping
  bank_id?: string;
  vault_id?: string | null;  // null = all vaults in bank
}
```

2. Update HybridSearchParams interface:
```typescript
export interface HybridSearchParams {
  query: string;
  limit?: number;
  supabase: SupabaseClient;
  userId: string;
  openaiApiKey: string;
  hfApiKey: string;
  filters?: SearchFilters;
}
```

3. Update executeHybridSearch to use the scoped function when bank/vault context is provided:
```typescript
// In executeHybridSearch, after query embedding generation:
const useScopedSearch = filters.bank_id || filters.vault_id;

if (useScopedSearch) {
  // Use vault-scoped search
  const { data: candidates, error } = await supabase.rpc('hybrid_search_transcripts_scoped', {
    query_text: query,
    query_embedding: queryEmbedding,
    match_count: candidateCount,
    full_text_weight: 1.0,
    semantic_weight: 1.0,
    rrf_k: 60,
    filter_user_id: userId,
    filter_bank_id: filters.bank_id || null,
    filter_vault_id: filters.vault_id || null,
    filter_date_start: filters.date_start || null,
    filter_date_end: filters.date_end || null,
    filter_speakers: filters.speakers || null,
    filter_categories: filters.categories || null,
    filter_recording_ids: filters.recording_ids || null,
    filter_topics: filters.topics || null,
    filter_sentiment: filters.sentiment || null,
    filter_intent_signals: filters.intent_signals || null,
    filter_user_tags: filters.user_tags || null,
  });
} else {
  // Fall back to existing unscoped search for pre-migration compatibility
  // ... existing hybrid_search_transcripts call
}
```

4. Update FormattedSearchResult to include vault attribution:
```typescript
export interface FormattedSearchResult {
  // ... existing fields
  vault_id?: string | null;
  vault_name?: string | null;  // For result attribution badges
}
```
  </action>
  <verify>
- SearchFilters includes bank_id and vault_id
- executeHybridSearch calls hybrid_search_transcripts_scoped when bank/vault present
- FormattedSearchResult includes vault attribution fields
- TypeScript compiles without errors
  </verify>
  <done>
- SearchFilters extended with bank/vault context
- Conditional logic to use scoped vs unscoped search
- Vault attribution included in results
  </done>
</task>

<task type="auto">
  <name>Task 3: Update chat-stream-v2 to pass bank/vault context to search</name>
  <files>
    supabase/functions/chat-stream-v2/index.ts
  </files>
  <action>
1. Update mergeFilters function to include bank/vault context:
```typescript
function mergeFilters(
  sessionFilters: SessionFilters | undefined,
  toolFilters: Partial<SearchFilters>,
  bankId?: string,
  vaultId?: string | null,
): SearchFilters {
  return {
    date_start: toolFilters.date_start || sessionFilters?.date_start,
    date_end: toolFilters.date_end || sessionFilters?.date_end,
    speakers: toolFilters.speakers || sessionFilters?.speakers,
    categories: toolFilters.categories || sessionFilters?.categories,
    recording_ids: toolFilters.recording_ids || sessionFilters?.recording_ids,
    topics: toolFilters.topics,
    sentiment: toolFilters.sentiment,
    intent_signals: toolFilters.intent_signals,
    user_tags: toolFilters.user_tags,
    // Always apply bank/vault context from request
    bank_id: bankId,
    vault_id: vaultId,
  };
}
```

2. Update the search helper in createTools to use bank/vault context:
```typescript
async function search(query: string, limit: number, toolFilters: Partial<SearchFilters> = {}) {
  const filters = mergeFilters(sessionFilters, toolFilters, bankId, vaultId);
  // ... rest of search implementation
}
```

3. Update the searchByEntity tool (which has custom search logic) to also respect bank/vault:
```typescript
// In searchByEntity execute function, when calling hybrid_search_transcripts:
// Replace hybrid_search_transcripts with hybrid_search_transcripts_scoped when bank/vault present
const useScopedSearch = bankId || vaultId;
const rpcFunction = useScopedSearch ? 'hybrid_search_transcripts_scoped' : 'hybrid_search_transcripts';

const { data: candidates, error } = await supabase.rpc(rpcFunction, {
  // ... existing params
  filter_bank_id: bankId || null,
  filter_vault_id: vaultId || null,
});
```

4. Update getCallDetails and getCallsList tools to respect vault scoping:
```typescript
// In getCallDetails, add vault membership check:
// Only return call details if user has access through vault membership

// In getCallsList, filter by accessible vaults:
// Join with vault_entries to only show calls in accessible vaults
```

5. Update compareCalls tool to respect vault scoping:
```typescript
// Filter recording_ids through vault_entries before comparison
```
  </action>
  <verify>
- mergeFilters includes bank_id and vault_id
- All search tools pass bank/vault context
- Analytical tools (getCallDetails, getCallsList) respect vault scoping
- Console logs show scoped search being used
  </verify>
  <done>
- All chat tools respect bank/vault context
- Searches are properly scoped to accessible vaults
- Logging confirms scoped search paths
  </done>
</task>

<task type="auto">
  <name>Task 4: Add vault attribution to search results</name>
  <files>
    supabase/functions/chat-stream-v2/index.ts
    supabase/functions/_shared/search-pipeline.ts
  </files>
  <action>
1. Update search result formatting to include vault attribution:
```typescript
// In search-pipeline.ts formatResults section:
results: diverse.map((r: SearchResult, i: number) => ({
  // ... existing fields
  vault_id: r.vault_id || null,
  vault_name: r.vault_name || null,  // For gray subtle badge on results
})),
```

2. Update system prompt to include vault attribution guidance:
```typescript
// In buildSystemPrompt, add vault attribution section:
VAULT ATTRIBUTION:
- Each search result may include a vault_name field
- When displaying results, mention which vault the content comes from
- Use format: "From [Vault Name]: ..." when attributing sources
- This helps users understand which knowledge container each result comes from
```

3. Add vault info to citation format:
```typescript
// Update CITATION INSTRUCTIONS in system prompt:
At the END of your response, include a sources list in this exact format:
  [1] Call Title (Speaker, Date) [Vault Name]
  [2] Another Call Title (Speaker, Date) [Vault Name]
```
  </action>
  <verify>
- Search results include vault_id and vault_name
- System prompt includes vault attribution guidance
- AI responses can reference vault sources
  </verify>
  <done>
- Vault attribution added to search results
- System prompt updated for vault context
- Citation format includes vault information
  </done>
</task>

</tasks>

<success_criteria>
1. Chat searches only return content from vaults user has VaultMembership in
2. Vault-selected mode: only VaultEntries in selected vault returned
3. Bank-level mode (vault_id null): union of VaultEntries in accessible vaults
4. BankMembership alone never exposes recordings
5. Search results include vault attribution (vault_name)
6. AI can reference which vault sources came from
</success_criteria>

<verification>
1. Create test scenario with user in Bank A with access to Vault 1 but not Vault 2
2. Verify chat in Vault 1 only returns Vault 1 content
3. Verify bank-level chat returns both Vault 1 and Vault 2 content if user has both memberships
4. Verify user without VaultMembership sees no content
5. Verify vault attribution appears in search results
</verification>
