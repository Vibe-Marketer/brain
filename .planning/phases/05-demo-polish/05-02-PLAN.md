---
phase: 05-demo-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/pages/AutomationRules.tsx
autonomous: true

must_haves:
  truths:
    - "Automation Rules page renders without crashing"
    - "Rule list displays rule names, descriptions, and enabled status"
    - "Trigger type icons and labels render correctly for all trigger types"
    - "CRUD operations complete without type errors in console"
  artifacts:
    - path: "src/pages/AutomationRules.tsx"
      provides: "Type-safe automation rules component"
      contains: "Database['public']['Tables']['automation_rules']"
  key_links:
    - from: "src/pages/AutomationRules.tsx"
      to: "src/integrations/supabase/types.ts"
      via: "Type import"
      pattern: "Database\\['public'\\]\\['Tables'\\]"
---

<objective>
Fix type mismatches between AutomationRules.tsx local types and Supabase schema

Purpose: AutomationRules.tsx defines local interfaces that diverge from Supabase types, causing potential runtime issues and blocking type safety.
Output: Type-aligned component that uses Database types directly
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-demo-polish/05-RESEARCH.md
@.planning/phases/05-demo-polish/05-01-SUMMARY.md

@src/pages/AutomationRules.tsx
@src/integrations/supabase/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace local types with Database types</name>
  <files>src/pages/AutomationRules.tsx</files>
  <action>
Replace the local interface with Supabase-derived types:

**1. Add Database type import at top:**
```typescript
import type { Database, Json } from '@/integrations/supabase/types';
```

**2. Replace the local `AutomationRule` interface (around lines 59-73) with:**
```typescript
// Use Supabase-generated type directly
type AutomationRule = Database['public']['Tables']['automation_rules']['Row'];

// Keep TriggerType for UI display purposes, but it's just a type guard
type TriggerType = 
  | "call_created"
  | "transcript_phrase"
  | "sentiment"
  | "duration"
  | "webhook"
  | "scheduled";

// Type guard for trigger_type since DB stores as string
function isTriggerType(value: string): value is TriggerType {
  return ["call_created", "transcript_phrase", "sentiment", "duration", "webhook", "scheduled"].includes(value);
}
```

**3. Update any places that cast trigger_type:**
The `getTriggerIcon` and `getTriggerLabel` functions currently expect `TriggerType` enum.
Update their parameter types to accept `string` and add runtime check:

```typescript
const getTriggerIcon = (triggerType: string) => {
  switch (triggerType) {
    // ... existing cases
  }
};

const getTriggerLabel = (triggerType: string): string => {
  switch (triggerType) {
    // ... existing cases
  }
};
```

**4. Handle Json type in UI:**
Where the code accesses `trigger_config`, `conditions`, or `actions`, these are now `Json` type.
Use type assertions when needed for display:

```typescript
// Example: accessing nested config
const config = rule.trigger_config as Record<string, unknown> | null;
```

This preserves type safety while acknowledging the JSON structure is defined at runtime.
  </action>
  <verify>
    - `npm run build` succeeds with no TypeScript errors in AutomationRules.tsx
    - `grep -n "Database\['public'\]" src/pages/AutomationRules.tsx` shows type import usage
    - `grep -n "interface AutomationRule" src/pages/AutomationRules.tsx` returns no matches (old interface removed)
  </verify>
  <done>
    AutomationRules.tsx uses Supabase Database types, compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add missing fields to component logic</name>
  <files>src/pages/AutomationRules.tsx</files>
  <action>
The Supabase schema includes fields not in the old interface:
- `schedule_config: Json | null`
- `next_run_at: string | null`

If the component displays rule details, add handling for these fields:

1. In any rule detail view, show schedule info if present:
```typescript
{rule.schedule_config && (
  <div>
    <span>Schedule: {JSON.stringify(rule.schedule_config)}</span>
    {rule.next_run_at && (
      <span>Next run: {new Date(rule.next_run_at).toLocaleString()}</span>
    )}
  </div>
)}
```

2. If there's a rule creation/edit form, ensure these fields can be set (or left null).

Note: This is additive - if the component doesn't render these fields currently, they can be safely ignored as optional fields.
  </action>
  <verify>
    - `npm run build` succeeds
    - Component renders without runtime errors (verify in browser)
  </verify>
  <done>
    Component handles all schema fields correctly
  </done>
</task>

</tasks>

<verification>
1. Type check: `npm run build` passes
2. Runtime: Navigate to `/automation-rules` - page renders without errors
3. Data display: If rules exist in DB, they display correctly
4. Console: No TypeScript runtime warnings about type mismatches
</verification>

<success_criteria>
- REFACTOR-04 addressed: AutomationRules.tsx uses Supabase Database types
- No TypeScript errors
- Backward compatible with existing data
- New schema fields handled appropriately
</success_criteria>

<output>
After completion, create `.planning/phases/05-demo-polish/05-02-SUMMARY.md`
</output>
