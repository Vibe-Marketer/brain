---
phase: 12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1
plan: 03
type: execute
wave: 3
depends_on: ["12-01", "12-02"]
files_modified:
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Worker entry point handles POST /mcp requests via createMcpHandler with all 16 operations registered"
    - "Unauthenticated requests to /mcp return 401 with WWW-Authenticate header pointing to protected resource metadata"
    - "GET /.well-known/oauth-protected-resource returns JSON pointing to Supabase as authorization server"
    - "All endpoints return proper CORS headers (OPTIONS preflight handled)"
    - "JWT validation uses jose + Supabase JWKS (RS256, no shared secret)"
    - "Local stdio server (src/index.ts) still compiles and runs with the old singleton pattern"
  artifacts:
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      provides: "Cloudflare Worker entry point with MCP handler, CORS, well-known endpoints, and auth"
      min_lines: 100
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      provides: "JWT validation middleware using jose + Supabase JWKS"
      exports: ["validateSupabaseToken"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts"
      provides: "Updated stdio entry point that creates RequestContext from old singleton pattern"
  key_links:
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      to: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      via: "Calls validateSupabaseToken before delegating to MCP handler"
      pattern: "validateSupabaseToken"
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      to: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts"
      via: "executeOperation called within MCP tool handlers with context"
      pattern: "executeOperation"
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      to: "createMcpHandler from agents/mcp"
      via: "Creates stateless MCP handler per request"
      pattern: "createMcpHandler"
---

<objective>
Create the Cloudflare Worker entry point that wires together the MCP protocol handler, JWT authentication, CORS, OAuth discovery endpoints, and all 16 CallVault operations. Also update the existing stdio entry point to work with the new context-threaded handlers.

Purpose: This is the "glue" plan that turns the ported handlers into a functioning remote MCP server. The Worker handles the HTTP lifecycle: CORS preflight, OAuth discovery, JWT validation, MCP server creation, and request delegation.

Output: A complete `worker.ts` that can serve MCP requests over Streamable HTTP, an `auth-middleware.ts` for JWT validation, and an updated `index.ts` for backward-compatible stdio operation.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/12-RESEARCH.md
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/RESEARCH-cloudflare-workers.md
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/RESEARCH-supabase-oauth.md
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/RESEARCH-mcp-client-compat.md

@/Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts (from Plan 01)
@/Users/Naegele/Developer/mcp/callvault-mcp/src/supabase.ts (from Plan 01)
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts (from Plan 02)
@/Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/prompts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth-middleware.ts and worker.ts entry point</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts
  </files>
  <action>
    **Create `src/auth-middleware.ts`** for JWT validation:

    ```typescript
    import { jwtVerify, createRemoteJWKSet } from 'jose';

    interface TokenValidationResult {
      valid: boolean;
      userId?: string;
      error?: string;
    }

    // Cache JWKS set per isolate (createRemoteJWKSet handles key caching internally)
    let cachedJWKS: ReturnType<typeof createRemoteJWKSet> | null = null;
    let cachedSupabaseUrl: string | null = null;

    function getJWKS(supabaseUrl: string) {
      if (cachedJWKS && cachedSupabaseUrl === supabaseUrl) return cachedJWKS;
      cachedJWKS = createRemoteJWKSet(new URL(`${supabaseUrl}/auth/v1/.well-known/jwks.json`));
      cachedSupabaseUrl = supabaseUrl;
      return cachedJWKS;
    }

    export async function validateSupabaseToken(
      request: Request,
      supabaseUrl: string
    ): Promise<TokenValidationResult> {
      const authHeader = request.headers.get('Authorization');
      if (!authHeader?.startsWith('Bearer ')) {
        return { valid: false, error: 'Missing Bearer token' };
      }

      const token = authHeader.slice(7);
      const JWKS = getJWKS(supabaseUrl);

      try {
        const { payload } = await jwtVerify(token, JWKS, {
          issuer: `${supabaseUrl}/auth/v1`,
          audience: 'authenticated',
        });
        return { valid: true, userId: payload.sub as string };
      } catch (err) {
        return { valid: false, error: String(err) };
      }
    }
    ```

    **Create `src/worker.ts`** as the Cloudflare Worker entry point:

    The Worker must handle these routes:
    1. `OPTIONS *` -- CORS preflight for all paths
    2. `GET /.well-known/oauth-protected-resource` -- RFC 9728 resource metadata pointing to Supabase
    3. `POST /mcp`, `GET /mcp`, `DELETE /mcp` -- MCP Streamable HTTP endpoint (delegated to createMcpHandler)
    4. Everything else: 404

    Structure:

    ```typescript
    import { createMcpHandler } from "agents/mcp";
    import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
    import { z } from "zod";
    import type { Env, RequestContext } from "./types.js";
    import { validateSupabaseToken } from "./auth-middleware.js";
    import { createSupabaseClient } from "./supabase.js";
    import { executeOperation } from "./handlers/index.js";
    import { PROMPTS, getPromptMessages } from "./prompts.js";
    import { log, chunkResponse, continueSession } from "./utils.js";
    import OPERATIONS from "./operations.json";
    ```

    **CORS helper function** `corsHeaders()`:
    Return headers per the research:
    ```
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Methods: GET, POST, DELETE, OPTIONS
    Access-Control-Allow-Headers: Content-Type, Accept, Authorization, Mcp-Session-Id, Last-Event-ID, MCP-Protocol-Version
    Access-Control-Expose-Headers: Content-Type, Authorization, Mcp-Session-Id
    Access-Control-Max-Age: 86400
    ```

    **`addCorsHeaders(response: Response): Response`** helper that clones a response and adds CORS headers.

    **OPTIONS handler**: Return `new Response(null, { status: 204, headers: corsHeaders() })`.

    **`/.well-known/oauth-protected-resource` handler** (GET):
    Return JSON:
    ```json
    {
      "resource": "https://callvault-mcp.callvault.workers.dev",
      "authorization_servers": ["${env.SUPABASE_URL}"],
      "scopes_supported": ["openid", "email"]
    }
    ```
    Use `env.SUPABASE_URL` from Worker bindings. Add CORS headers. Content-Type: application/json.

    **`/mcp` handler** (POST, GET, DELETE):

    1. Check for Authorization header. If missing or invalid, return 401 with:
       ```
       WWW-Authenticate: Bearer resource_metadata="https://callvault-mcp.callvault.workers.dev/.well-known/oauth-protected-resource"
       ```
       Also add CORS headers to the 401 response. Return JSON body: `{"error": "Unauthorized", "hint": "Include Authorization: Bearer <token> header"}`.

    2. Call `validateSupabaseToken(request, env.SUPABASE_URL)`.
       - If invalid: return 401 with error details + CORS headers.

    3. Create per-request Supabase client:
       ```typescript
       const supabase = createSupabaseClient(env.SUPABASE_URL, env.SUPABASE_ANON_KEY, token);
       const context: RequestContext = { supabase, userId };
       ```

    4. Create a fresh McpServer instance (per-request, as required by MCP SDK 1.26.0+):
       ```typescript
       const server = createMcpServer(OPERATIONS, context);
       ```

    5. Create the MCP handler and delegate:
       ```typescript
       const handler = createMcpHandler(server);
       const response = await handler(request, env, ctx);
       return addCorsHeaders(response);
       ```

    **`createMcpServer(operations, context)` factory function** (in same file or extracted):

    Creates a new `McpServer` with:
    - `name: "callvault-mcp"`, `version: "1.0.0"`
    - Registers the same 4 meta-tools as the stdio server: `callvault_discover`, `callvault_get_schema`, `callvault_execute`, `callvault_continue`
    - Tool handlers use `context` (closure) to pass to `executeOperation(operation, params, context)`
    - Port the tool implementation logic EXACTLY from `src/index.ts` (the `CallToolRequestSchema` handler), but adapted to `server.tool()` format with zod schemas
    - Also register resources and prompts from the existing `src/index.ts` patterns

    For the 4 tools using zod schemas:

    ```typescript
    server.tool("callvault_discover", { category: z.string().optional() }, async ({ category }) => {
      // ... same logic as current CallToolRequestSchema handler for "callvault_discover" case
      return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
    });

    server.tool("callvault_get_schema", { operation: z.string() }, async ({ operation }) => {
      // ... same logic
    });

    server.tool("callvault_execute", {
      operation: z.string(),
      params: z.record(z.unknown()).optional(),
      offset: z.number().optional(),
      limit: z.number().optional(),
    }, async ({ operation, params, offset, limit }) => {
      const result = await executeOperation(operation, { ...params, offset, limit }, context);
      // Handle chunked responses same as current index.ts
      // ...
    });

    server.tool("callvault_continue", { session_id: z.string() }, async ({ session_id }) => {
      const { text } = continueSession(session_id);
      return { content: [{ type: "text", text }] };
    });
    ```

    **Export the Worker handler as default**:
    ```typescript
    export default {
      async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
        // Route to the appropriate handler based on URL path and method
      }
    };
    ```

    **IMPORTANT: No Durable Object export.** The wrangler.jsonc has no DO config. The Worker is purely stateless.

    **Error handling**: Wrap the entire fetch handler in try/catch. On unhandled errors, return 500 with JSON body and CORS headers.
  </action>
  <verify>
    1. `npx tsc --noEmit -p /Users/Naegele/Developer/mcp/callvault-mcp/tsconfig.worker.json` passes with no errors
    2. `grep "createMcpHandler" /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts` returns at least 1 match
    3. `grep "validateSupabaseToken" /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts` returns at least 1 match
    4. `grep "oauth-protected-resource" /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts` returns at least 1 match
    5. `grep "Access-Control-Allow" /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts` returns multiple matches
    6. `grep "callvault_discover\|callvault_get_schema\|callvault_execute\|callvault_continue" /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts` returns 4 distinct tool names
    7. `cd /Users/Naegele/Developer/mcp/callvault-mcp && npx wrangler dev --test-scheduled 2>&1 | head -5` starts without crash (may fail at runtime due to missing secrets, but should load)
  </verify>
  <done>
    Worker entry point created with: CORS for all endpoints, /.well-known/oauth-protected-resource discovery, JWT validation via jose/JWKS, per-request McpServer with all 4 meta-tools registered, and proper 401 responses with WWW-Authenticate headers for OAuth auto-discovery.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update stdio entry point (index.ts) for backward compatibility</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts
  </files>
  <action>
    Update `src/index.ts` to work with the new context-threaded `executeOperation` signature. The stdio server must continue to function for local development (MCP-REMOTE-08).

    **Changes needed:**

    1. Import `RequestContext` from `./types.js`
    2. Import `getSupabaseClient, getCurrentUserId` from `./supabase.js` (these old functions still exist for stdio mode)
    3. In the `CallToolRequestSchema` handler, for the `callvault_execute` case, create a RequestContext before calling executeOperation:
       ```typescript
       case "callvault_execute": {
         const operation = (args as any)?.operation;
         const params = (args as any)?.params || {};
         if (!operation) throw new Error("Operation is required");

         // Create context from stdio session
         const supabase = await getSupabaseClient();
         const userId = getCurrentUserId();
         const context: RequestContext = { supabase, userId };

         result = await executeOperation(operation, params, context);
         break;
       }
       ```
    4. The `callvault_continue` case already works (uses `continueSession` from utils, which is unchanged).
    5. The `callvault_discover` and `callvault_get_schema` cases don't call `executeOperation`, so they are unchanged.
    6. Keep the existing `readFileSync` for loading operations.json -- this is the Node.js entry point.
    7. Keep `StdioServerTransport` and `main()` function unchanged.

    **Verify the stdio build still works:**
    `npm run build` should succeed (compiles with tsconfig.json targeting Node16).
  </action>
  <verify>
    1. `cd /Users/Naegele/Developer/mcp/callvault-mcp && npm run build` succeeds without errors
    2. `grep "RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts` shows the import
    3. `grep "executeOperation.*context" /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts` shows context being passed
    4. The stdio server can still be started: `node /Users/Naegele/Developer/mcp/callvault-mcp/dist/src/index.js 2>&1 | head -3` (it will error about missing session, which is expected behavior)
  </verify>
  <done>
    Stdio entry point updated to create RequestContext from the old singleton pattern and pass it to the context-threaded executeOperation. `npm run build` succeeds. Local stdio MCP server preserved per MCP-REMOTE-08.
  </done>
</task>

</tasks>

<verification>
- Worker entry point handles CORS, OAuth discovery, JWT auth, and MCP requests
- 401 responses include WWW-Authenticate header with resource_metadata URL
- /.well-known/oauth-protected-resource returns valid JSON pointing to Supabase
- All 4 meta-tools registered in per-request McpServer
- auth-middleware validates JWTs via jose + Supabase JWKS
- Stdio server builds and runs (backward compatibility)
- TypeScript compiles for both Worker (tsconfig.worker.json) and stdio (tsconfig.json) targets
</verification>

<success_criteria>
The Worker entry point is complete and ready for deployment. It handles the full MCP lifecycle: CORS preflight, OAuth discovery, token validation, MCP server creation with all 16 operations, and proper error responses. The stdio server remains functional.
</success_criteria>

<output>
After completion, create `.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/12-03-SUMMARY.md`
</output>
