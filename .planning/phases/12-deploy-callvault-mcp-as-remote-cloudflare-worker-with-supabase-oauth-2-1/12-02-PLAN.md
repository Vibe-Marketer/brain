---
phase: 12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/search.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/contacts.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/analysis.ts
autonomous: true

must_haves:
  truths:
    - "All 16 handler operations accept RequestContext as a parameter instead of calling module-level singletons"
    - "No handler file imports getSupabaseClient() or getCurrentUserId() (all use context parameter)"
    - "executeOperation() accepts a RequestContext parameter and passes it to every handler"
    - "All handler business logic is unchanged (same Supabase queries, same field configs, same dual-schema fallbacks)"
  artifacts:
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts"
      provides: "Updated operation router that threads context"
      exports: ["executeOperation", "getAvailableOperations"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts"
      provides: "Navigation handlers with context parameter"
      exports: ["listBanks", "listVaults", "listFolders", "listTags"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts"
      provides: "Recording handlers with context parameter"
      exports: ["searchRecordings", "getRecording", "listRecordings"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts"
      provides: "Transcript handlers with context parameter"
      exports: ["getTranscriptRaw", "getTranscriptStructured", "getTranscriptTimestamped"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/search.ts"
      provides: "Semantic search handler with context parameter"
      exports: ["semanticSearch"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/contacts.ts"
      provides: "Contact handlers with context parameter"
      exports: ["listContacts", "getContactHistory", "getAttendees"]
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/analysis.ts"
      provides: "Analysis handlers with context parameter"
      exports: ["compareRecordings", "trackSpeaker"]
  key_links:
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts"
      to: "/Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts"
      via: "Imports RequestContext type"
      pattern: "import.*RequestContext.*from.*types"
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts"
      to: "all handler files"
      via: "Passes context to every handler invocation"
      pattern: "handler\\(params,\\s*context\\)"
---

<objective>
Thread RequestContext through all 16 handler operations so they receive a per-request Supabase client and userId instead of calling module-level singletons.

Purpose: This is the core mechanical migration that makes all handler business logic portable to Cloudflare Workers. Every handler currently calls `getSupabaseClient()` and `getCurrentUserId()` from module-level state. These must be replaced with explicit context parameters for the stateless Worker model.

Output: All 7 handler files updated with context parameter. Zero business logic changes -- only the plumbing for how they get the Supabase client and userId.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/12-RESEARCH.md
@/Users/Naegele/dev/brain/.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/RESEARCH-codebase-analysis.md

@/Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts (created in Plan 01)
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/search.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/contacts.ts
@/Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/analysis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread RequestContext through navigation, recordings, and transcripts handlers</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts
  </files>
  <action>
    Apply the same mechanical transformation to each of these three files:

    **Pattern for each handler function:**

    Before:
    ```typescript
    export async function listBanks(params: any): Promise<unknown> {
      const supabase = await getSupabaseClient();
      const userId = getCurrentUserId();
      // ... business logic using supabase and userId ...
    }
    ```

    After:
    ```typescript
    import type { RequestContext } from "../types.js";

    export async function listBanks(params: any, context: RequestContext): Promise<unknown> {
      const { supabase, userId } = context;
      // ... business logic using supabase and userId UNCHANGED ...
    }
    ```

    **For each file:**

    1. Add `import type { RequestContext } from "../types.js";` at the top
    2. Remove `import { getSupabaseClient, getCurrentUserId } from "../supabase.js";` (or similar)
    3. Add `context: RequestContext` as the second parameter to every exported function
    4. Replace `const supabase = await getSupabaseClient();` with `const { supabase, userId } = context;`
    5. Replace `const userId = getCurrentUserId();` (already destructured above)
    6. DO NOT change any Supabase query logic, field configs, dual-schema fallbacks, or response shaping

    **navigation.ts specifics (4 functions):**
    - `listBanks(params, context)` -- queries bank_memberships JOIN banks
    - `listVaults(params, context)` -- queries vault_memberships JOIN vaults
    - `listFolders(params, context)` -- queries folders
    - `listTags(params, context)` -- queries call_tags (may not use userId but add context anyway for consistency)

    **recordings.ts specifics (3 functions):**
    - `searchRecordings(params, context)` -- uses chunkResponse, keep it
    - `getRecording(params, context)` -- dual-schema fallback (recordings then fathom_calls), preserve exactly
    - `listRecordings(params, context)` -- uses chunkResponse, keep it

    **transcripts.ts specifics (3 exported + 3 private helpers):**
    - Private helpers `getTranscriptText`, `getSpeakerEmails` also call getSupabaseClient/getCurrentUserId. Thread context through them too.
    - `getTranscriptRaw(params, context)` -> calls `getTranscriptText(recordingId, context)`
    - `getTranscriptStructured(params, context)` -> calls `getTranscriptText(recordingId, context)` + `getSpeakerEmails(legacyId, context)`
    - `getTranscriptTimestamped(params, context)` -> queries directly + uses chunkResponse
    - `parseTranscript(text)` is a pure function -- leave it completely unchanged

    **Critical preservation rules:**
    - All Supabase query patterns (`.from()`, `.select()`, `.eq()`, `.order()`, `.filter()`) are UNCHANGED
    - The dual-schema fallback (try recordings, fall back to fathom_calls) MUST be preserved exactly
    - `chunkResponse()` calls are kept as-is (utils.ts was already updated in Plan 01)
    - Field projection via `truncateList()` and `extractFields()` remains unchanged
  </action>
  <verify>
    1. `grep -r "getSupabaseClient" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts` returns no matches
    2. `grep -r "getCurrentUserId" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts` returns no matches
    3. `grep -c "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts` returns 4
    4. `grep -c "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts` returns 3
    5. `grep -c "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/transcripts.ts` returns at least 3 (exported) plus private helpers
  </verify>
  <done>
    Navigation (4 ops), recordings (3 ops), and transcripts (3 ops) handlers all accept RequestContext parameter. No business logic changes. No imports of module-level singletons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread RequestContext through search, contacts, analysis handlers + update router</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/search.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/contacts.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/analysis.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts
  </files>
  <action>
    **Apply the same context threading pattern to the remaining three handler files:**

    **search.ts (1 function):**
    - `semanticSearch(params, context)` -- calls `supabase.functions.invoke("semantic-search", ...)`. The `supabase.functions.invoke()` method works identically in Workers (it is HTTP-based). Thread context and use `context.userId` where `getCurrentUserId()` was called.

    **contacts.ts (3 functions):**
    - `listContacts(params, context)` -- two serial queries, thread context
    - `getContactHistory(params, context)` -- multiple queries, thread context
    - `getAttendees(params, context)` -- queries fathom_calls + fathom_transcripts, thread context

    **analysis.ts (2 functions):**
    - `compareRecordings(params, context)` -- loops over recording IDs, queries recordings then fathom_calls per ID. Thread context. Preserve the loop and dual-schema fallback exactly.
    - `trackSpeaker(params, context)` -- queries fathom_transcripts filtered by speaker. Thread context.

    **Update `src/handlers/index.ts` (the router):**

    1. Add `import type { RequestContext } from "../types.js";`
    2. Change the handler function type:
       ```typescript
       type HandlerFn = (params: any, context: RequestContext) => Promise<unknown>;
       ```
    3. Update `executeOperation` signature:
       ```typescript
       export async function executeOperation(
         operation: string,
         params: Record<string, unknown>,
         context: RequestContext
       ): Promise<unknown> {
         const handler = HANDLERS[operation];
         if (!handler) {
           throw new Error(`Unknown operation: ${operation}. Use 'callvault_discover' to see available operations.`);
         }
         return handler(params, context);
       }
       ```
    4. The `HANDLERS` Record values (function references) already match since all handler functions now have the `(params, context)` signature.
    5. `getAvailableOperations()` remains unchanged (returns string array of operation keys).

    **Patch `src/index.ts` for temporary TypeScript compatibility:**

    After updating `executeOperation` to require a `context` parameter, the existing `src/index.ts` (stdio entry) calls `executeOperation(operation, params)` WITHOUT context on line ~208. This will cause a TypeScript compilation error on `npm run build`.

    To keep the stdio build working until Plan 03 Task 2 does the full `index.ts` update:

    1. In `src/index.ts`, find the line `result = await executeOperation(operation, params);` (in the `callvault_execute` case of the `CallToolRequestSchema` handler)
    2. Add `// @ts-expect-error -- context parameter added in Plan 02, full stdio update in Plan 03` on the line directly above the `executeOperation` call
    3. This suppresses the type error without changing runtime behavior (executeOperation will receive `undefined` for context, which is fine because the stdio handlers still use the old singleton pattern internally during this transitional state)

    **Do NOT do a full index.ts rewrite here** -- that is Plan 03 Task 2's responsibility. This is only a one-line suppression to keep the build green.
  </action>
  <verify>
    1. `grep -r "getSupabaseClient\|getCurrentUserId" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/` returns NO matches in any handler file
    2. `grep -c "RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts` returns at least 2 (import + type + function sig)
    3. `grep "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/search.ts` returns 1
    4. `grep "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/contacts.ts` returns 3
    5. `grep "context: RequestContext" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/analysis.ts` returns 2
    6. `grep "handler(params, context)" /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts` returns 1
    7. `cd /Users/Naegele/Developer/mcp/callvault-mcp && npm run build` succeeds (stdio build still green thanks to @ts-expect-error)
    8. `grep "ts-expect-error" /Users/Naegele/Developer/mcp/callvault-mcp/src/index.ts` returns 1 match (temporary suppression in place)
  </verify>
  <done>
    All 16 handler operations accept RequestContext. The router passes context to every handler. No handler file imports module-level singletons. Business logic unchanged across all handlers. Stdio build remains green via temporary @ts-expect-error (to be removed in Plan 03 Task 2).
  </done>
</task>

</tasks>

<verification>
- Zero occurrences of `getSupabaseClient` or `getCurrentUserId` in any file under `src/handlers/`
- All 16 operations in the HANDLERS record use the `(params, context)` signature
- `executeOperation` accepts and passes `RequestContext`
- All Supabase query patterns, dual-schema fallbacks, and response shaping preserved exactly
- `parseTranscript()` in transcripts.ts remains a pure function with no context parameter
- `npm run build` succeeds (stdio server preserved with temporary @ts-expect-error)
</verification>

<success_criteria>
All handler files are portable to Workers via explicit context threading. The handler code is identical in business logic to the original -- only the mechanism for obtaining the Supabase client and userId has changed from module singletons to function parameters. The stdio build remains green.
</success_criteria>

<output>
After completion, create `.planning/phases/12-deploy-callvault-mcp-as-remote-cloudflare-worker-with-supabase-oauth-2-1/12-02-SUMMARY.md`
</output>
