---
phase: 16-workspace-redesign
plan: 04
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - /Users/Naegele/dev/callvault/src/services/folders.service.ts
  - /Users/Naegele/dev/callvault/src/hooks/useFolders.ts
  - /Users/Naegele/dev/callvault/src/hooks/useFolderAssignment.ts
  - /Users/Naegele/dev/callvault/src/components/dnd/FolderDropZone.tsx
  - /Users/Naegele/dev/callvault/src/components/dnd/DndCallProvider.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a folder inside a workspace"
    - "User can rename a folder"
    - "User can archive a folder (moves to Archived section, excluded from searches)"
    - "User can restore an archived folder"
    - "User can drag a call onto a sidebar folder to assign it (desktop)"
    - "User can assign a call to a folder via action menu (all devices)"
    - "Folder depth is max 2 levels (one level of nesting)"
  artifacts:
    - path: "/Users/Naegele/dev/callvault/src/services/folders.service.ts"
      provides: "CRUD + archive operations for folders scoped to workspace"
      exports: ["getFolders", "createFolder", "renameFolder", "archiveFolder", "restoreFolder"]
    - path: "/Users/Naegele/dev/callvault/src/hooks/useFolders.ts"
      provides: "TanStack Query hooks for workspace-scoped folders"
      exports: ["useFolders", "useCreateFolder", "useRenameFolder", "useArchiveFolder"]
    - path: "/Users/Naegele/dev/callvault/src/hooks/useFolderAssignment.ts"
      provides: "Hook for assigning/moving calls to folders"
      exports: ["useAssignToFolder"]
    - path: "/Users/Naegele/dev/callvault/src/components/dnd/FolderDropZone.tsx"
      provides: "Drop target component for sidebar folders using @dnd-kit/core"
      contains: "useDroppable"
    - path: "/Users/Naegele/dev/callvault/src/components/dnd/DndCallProvider.tsx"
      provides: "DndContext provider wrapping the calls list for drag-to-folder"
      contains: "DndContext"
  key_links:
    - from: "/Users/Naegele/dev/callvault/src/services/folders.service.ts"
      to: "supabase.from('folders')"
      via: "All folder queries use folders table with vault_id filter"
      pattern: "from\\('folders'\\).*eq\\('vault_id'"
    - from: "/Users/Naegele/dev/callvault/src/components/dnd/FolderDropZone.tsx"
      to: "/Users/Naegele/dev/callvault/src/hooks/useFolderAssignment.ts"
      via: "Drop handler calls assignToFolder mutation"
      pattern: "useAssignToFolder"
    - from: "/Users/Naegele/dev/callvault/src/hooks/useFolders.ts"
      to: "/Users/Naegele/dev/callvault/src/stores/orgContextStore.ts"
      via: "useFolders reads activeWorkspaceId from orgContextStore"
      pattern: "activeWorkspaceId"
---

<objective>
Build complete folder management: CRUD operations, archive/restore, drag-and-drop assignment, and action menu assignment.

Purpose: WKSP-12 requires create, rename, archive folders inside a workspace. The locked decisions specify drag-and-drop on desktop AND action menu everywhere for call-to-folder assignment, one level of nesting (max 2 levels deep), and archived folders in an "Archived" section.

Output: Folder service layer, TanStack Query hooks, DnD infrastructure, folder assignment hook.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/Naegele/dev/brain/.planning/phases/16-workspace-redesign/16-CONTEXT.md
@/Users/Naegele/dev/brain/.planning/phases/16-workspace-redesign/16-RESEARCH.md
@/Users/Naegele/dev/brain/.planning/phases/16-workspace-redesign/16-02-SUMMARY.md
@/Users/Naegele/dev/callvault/src/types/workspace.ts
@/Users/Naegele/dev/callvault/src/stores/orgContextStore.ts
@/Users/Naegele/dev/callvault/src/lib/query-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Folder service layer and TanStack Query hooks</name>
  <files>
    /Users/Naegele/dev/callvault/src/services/folders.service.ts
    /Users/Naegele/dev/callvault/src/hooks/useFolders.ts
    /Users/Naegele/dev/callvault/src/hooks/useFolderAssignment.ts
  </files>
  <action>
    **src/services/folders.service.ts** — Service layer for folder operations. All queries use `supabase.from('folders')`.

    Functions:
    - `getFolders(supabase, workspaceId, includeArchived = false)` — Query folders where vault_id = workspaceId. If includeArchived is false, filter `is_archived = false`. Order by position ASC. Return `Folder[]`.
    - `getArchivedFolders(supabase, workspaceId)` — Query folders where vault_id = workspaceId AND is_archived = true.
    - `createFolder(supabase, workspaceId, bankId, userId, name, parentFolderId?)` — Insert into folders. Set vault_id, bank_id, user_id, name, parent_folder_id. If parentFolderId is provided, verify the parent has no parent itself (enforce max 2 levels deep). Position: set to max(position) + 1 for folders in same workspace/parent.
    - `renameFolder(supabase, folderId, name)` — Update folder name.
    - `archiveFolder(supabase, folderId)` — Set is_archived = true, archived_at = NOW(). Per locked decision: "Calls stay inside the archived folder. Folder is hidden from main sidebar view. Can be fully restored."
    - `restoreFolder(supabase, folderId)` — Set is_archived = false, archived_at = null.
    - `deleteFolder(supabase, folderId)` — Hard delete (only for empty folders — check for folder_assignments count first).
    - `assignCallToFolder(supabase, recordingId, folderId)` — Upsert into folder_assignments table. Check if table uses recording_id or some other FK — read existing folder_assignments schema from supabase types.
    - `removeCallFromFolder(supabase, recordingId, folderId)` — Delete from folder_assignments.
    - `moveCallToFolder(supabase, recordingId, fromFolderId, toFolderId)` — Remove from old, add to new (transaction via RPC if needed, or sequential).

    **IMPORTANT:** Enforce folder nesting depth limit in createFolder. If parentFolderId is provided, query the parent folder. If parent already has a parent_folder_id (non-null), reject with an error: "Folders can only be nested one level deep."

    **src/hooks/useFolders.ts** — TanStack Query hooks:
    - `useFolders(workspaceId)` — Active folders for workspace. Uses `queryKeys.folders.list(workspaceId)`. Enabled when workspaceId is not null.
    - `useArchivedFolders(workspaceId)` — Archived folders, separate query key.
    - `useCreateFolder()` — Mutation. On success: invalidate folders list, show success toast via sonner.
    - `useRenameFolder()` — Mutation with optimistic update (update folder name immediately, rollback on error).
    - `useArchiveFolder()` — Mutation. On success: invalidate both active and archived folder lists, show toast "Folder archived".
    - `useRestoreFolder()` — Mutation. On success: invalidate both lists, show toast "Folder restored".

    **src/hooks/useFolderAssignment.ts** — TanStack Query hook for call-to-folder assignment:
    - `useAssignToFolder()` — Mutation wrapping assignCallToFolder service. On success: invalidate folder detail and recordings list. Show toast "Call moved to {folderName}".
    - `useRemoveFromFolder()` — Mutation wrapping removeCallFromFolder. On success: invalidate, toast "Call removed from folder".
  </action>
  <verify>
    1. `cd /Users/Naegele/dev/callvault && pnpm build` succeeds
    2. `grep "vault_id" src/services/folders.service.ts` confirms workspace-scoped queries
    3. `grep "is_archived" src/services/folders.service.ts` confirms archive support
    4. `grep "parent_folder_id" src/services/folders.service.ts` confirms nesting depth check
  </verify>
  <done>
    Folder service supports CRUD, archive/restore, call assignment. Nesting limited to 2 levels. TanStack Query hooks for all operations with optimistic updates and toast notifications.
  </done>
</task>

<task type="auto">
  <name>Task 2: Drag-and-drop infrastructure for call-to-folder assignment</name>
  <files>
    /Users/Naegele/dev/callvault/src/components/dnd/FolderDropZone.tsx
    /Users/Naegele/dev/callvault/src/components/dnd/DndCallProvider.tsx
  </files>
  <action>
    **src/components/dnd/DndCallProvider.tsx** — Wraps the calls list with @dnd-kit DndContext. Per locked decision: "Drag-and-drop on desktop" for call-to-folder assignment.

    Implementation:
    - Import `DndContext, DragOverlay, MouseSensor, TouchSensor, useSensor, useSensors` from `@dnd-kit/core`
    - Wrap children (calls list) in `<DndContext>`
    - Sensors: MouseSensor with 10px activation distance (prevents accidental drags), TouchSensor with 250ms delay
    - `onDragEnd` handler: extract `active.id` (recording ID) and `over?.id` (folder ID from drop zone). If over exists and starts with "folder-", call `useAssignToFolder()` mutation
    - DragOverlay: Show a lightweight card preview of the dragged call (just title + mini icon)
    - Store drag state in local useState (not Zustand — ephemeral)

    **src/components/dnd/FolderDropZone.tsx** — Drop target component for sidebar folders.

    Implementation per research pattern:
    ```typescript
    import { useDroppable } from '@dnd-kit/core'

    function FolderDropZone({ folder, children }) {
      const { isOver, setNodeRef } = useDroppable({ id: `folder-${folder.id}` })

      return (
        <div
          ref={setNodeRef}
          className={cn(
            'rounded-lg transition-colors duration-150',
            isOver && 'bg-brand-400/10 ring-1 ring-brand-400/40'
          )}
        >
          {children}
        </div>
      )
    }
    ```

    - Visual feedback on hover: subtle orange highlight ring matching brand colors
    - Announce via aria-live when drag starts/ends for screen readers
    - Only active on desktop (check useBreakpointFlags — disable DnD on mobile/tablet)

    Also create a `DraggableCallRow` wrapper for individual call list items:
    ```typescript
    import { useDraggable } from '@dnd-kit/core'

    function DraggableCallRow({ recordingId, children }) {
      const { attributes, listeners, setNodeRef, isDragging } = useDraggable({
        id: `recording-${recordingId}`,
      })

      return (
        <div
          ref={setNodeRef}
          {...attributes}
          {...listeners}
          className={cn(isDragging && 'opacity-50')}
        >
          {children}
        </div>
      )
    }
    ```

    Export both FolderDropZone and DraggableCallRow for use in WorkspaceSidebarPane (Plan 03) and the calls list.
  </action>
  <verify>
    1. `cd /Users/Naegele/dev/callvault && pnpm build` succeeds
    2. `grep "@dnd-kit/core" src/components/dnd/DndCallProvider.tsx` confirms dnd-kit usage
    3. `grep "useDroppable" src/components/dnd/FolderDropZone.tsx` confirms drop zone
    4. `grep "useDraggable" src/components/dnd/DndCallProvider.tsx` confirms draggable setup
  </verify>
  <done>
    DndCallProvider wraps calls list with DndContext, handles drag-to-folder assignment via onDragEnd. FolderDropZone provides visual hover feedback on sidebar folders. DraggableCallRow enables individual calls to be dragged. Desktop only (disabled on mobile/tablet). Accessible via aria-live announcements.
  </done>
</task>

</tasks>

<verification>
- Folder CRUD operations work via service functions
- Archive/restore toggles is_archived and archived_at
- Nesting limited to 2 levels (enforced in createFolder)
- DnD infrastructure compiles and uses @dnd-kit/core
- Call assignment creates folder_assignments records
- pnpm build passes clean
</verification>

<success_criteria>
1. Folder service provides workspace-scoped CRUD with vault_id filtering
2. Archive/restore changes visibility without deleting data
3. Folder nesting depth enforced at max 2 levels
4. DnD context wraps calls list, folder drop zones in sidebar
5. Call-to-folder assignment works via both DnD and service function
6. Build passes with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-workspace-redesign/16-04-SUMMARY.md`
</output>
