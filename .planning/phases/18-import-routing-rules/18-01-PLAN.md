---
phase: 18-import-routing-rules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260228000003_create_import_routing_rules.sql
  - supabase/functions/_shared/routing-engine.ts
  - supabase/functions/_shared/connector-pipeline.ts
autonomous: true

must_haves:
  truths:
    - "Routing rules table exists with priority column from the first migration (IMP-10)"
    - "Default destination table exists for org-level fallback (IMP-07)"
    - "Rules are organization-scoped via bank_id with RLS enforcing bank membership"
    - "Routing engine evaluates conditions against a ConnectorRecord and returns first match (IMP-06)"
    - "Pipeline resolves routing destination before inserting recording"
    - "Routing trace metadata (rule name, timestamp) is stored in source_metadata"
  artifacts:
    - path: "supabase/migrations/20260228000003_create_import_routing_rules.sql"
      provides: "import_routing_rules + import_routing_defaults tables, RLS, priority update RPC"
      contains: "import_routing_rules"
    - path: "supabase/functions/_shared/routing-engine.ts"
      provides: "resolveRoutingDestination() and condition evaluation functions"
      exports: ["resolveRoutingDestination"]
    - path: "supabase/functions/_shared/connector-pipeline.ts"
      provides: "Modified runPipeline() with routing resolution pre-step"
      exports: ["runPipeline", "insertRecording", "checkDuplicate", "ConnectorRecord"]
  key_links:
    - from: "supabase/functions/_shared/connector-pipeline.ts"
      to: "supabase/functions/_shared/routing-engine.ts"
      via: "import resolveRoutingDestination"
      pattern: "import.*resolveRoutingDestination.*routing-engine"
    - from: "supabase/functions/_shared/routing-engine.ts"
      to: "import_routing_rules table"
      via: "supabase.from('import_routing_rules') query"
      pattern: "from\\('import_routing_rules'\\)"
    - from: "supabase/functions/_shared/connector-pipeline.ts"
      to: "import_routing_defaults table"
      via: "supabase.from('import_routing_defaults') query for fallback"
      pattern: "from\\('import_routing_defaults'\\)"
---

<objective>
Create the database schema for import routing rules and the server-side routing engine that evaluates rules during the connector pipeline.

Purpose: This is the backend foundation. Without the tables and engine, no frontend can manage or preview rules, and no imported call can be auto-routed. The priority column must exist from the first migration (IMP-10). The routing engine is the first-match-wins evaluator that runs inside `runPipeline()`.

Output: Migration SQL deployed, `routing-engine.ts` created, `connector-pipeline.ts` modified to call routing before insert.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-import-routing-rules/18-CONTEXT.md
@.planning/phases/18-import-routing-rules/18-RESEARCH.md
@.planning/phases/17-import-connector-pipeline/17-01-SUMMARY.md
@supabase/functions/_shared/connector-pipeline.ts
@supabase/migrations/20260228000002_create_import_sources.sql
@supabase/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routing rules database migration</name>
  <files>supabase/migrations/20260228000003_create_import_routing_rules.sql</files>
  <action>
Create the migration file with two tables and one RPC function:

**Table 1: `import_routing_rules`**
- `id` UUID PK DEFAULT gen_random_uuid()
- `bank_id` UUID NOT NULL REFERENCES banks(id) ON DELETE CASCADE — rules are org-scoped (locked decision), NOT user-scoped
- `name` TEXT NOT NULL — rule name is required (locked decision)
- `priority` INTEGER NOT NULL DEFAULT 0 — IMP-10: priority from first migration. Lower number = higher priority
- `enabled` BOOLEAN NOT NULL DEFAULT true — enabled/disabled toggle (locked decision)
- `conditions` JSONB NOT NULL DEFAULT '[]' — array of {field, operator, value} objects
- `logic_operator` TEXT NOT NULL DEFAULT 'AND' — 'AND' | 'OR' (locked decision: AND/OR toggle)
- `target_vault_id` UUID NOT NULL REFERENCES vaults(id) ON DELETE RESTRICT — destination workspace (required)
- `target_folder_id` UUID REFERENCES folders(id) ON DELETE SET NULL — destination folder (optional)
- `created_by` UUID NOT NULL REFERENCES auth.users(id)
- `created_at` TIMESTAMPTZ NOT NULL DEFAULT now()
- `updated_at` TIMESTAMPTZ NOT NULL DEFAULT now()

Add compound index: `idx_routing_rules_bank_priority ON import_routing_rules(bank_id, priority) WHERE enabled = true`

**Table 2: `import_routing_defaults`**
- `bank_id` UUID PRIMARY KEY REFERENCES banks(id) ON DELETE CASCADE
- `target_vault_id` UUID NOT NULL REFERENCES vaults(id) ON DELETE RESTRICT
- `target_folder_id` UUID REFERENCES folders(id) ON DELETE SET NULL
- `updated_by` UUID NOT NULL REFERENCES auth.users(id)
- `updated_at` TIMESTAMPTZ NOT NULL DEFAULT now()

**RLS policies for both tables** — use bank_memberships join pattern (same as import_sources):
- SELECT: EXISTS (SELECT 1 FROM bank_memberships WHERE bank_id = table.bank_id AND user_id = auth.uid())
- INSERT: same bank_memberships check + auth.uid() = created_by (for rules) or auth.uid() = updated_by (for defaults)
- UPDATE: same bank_memberships check
- DELETE: same bank_memberships check (rules only; defaults uses upsert, no delete needed)

**RPC function: `update_routing_rule_priorities(p_bank_id UUID, p_rule_ids UUID[])`**
- SECURITY DEFINER
- Verify caller is bank member via bank_memberships check
- Loop through p_rule_ids array, set priority = array index (1-based)
- Update `updated_at = now()` for each

Deploy to production using: `supabase db push --linked`

Follow the migration file format from supabase/CLAUDE.md (section headers, comments, RLS enable).
  </action>
  <verify>
Run `supabase db push --linked` — migration applies cleanly.
Verify via psql:
- `SELECT count(*) FROM information_schema.tables WHERE table_name IN ('import_routing_rules', 'import_routing_defaults');` returns 2
- `SELECT count(*) FROM pg_policies WHERE tablename = 'import_routing_rules';` returns 4 (SELECT, INSERT, UPDATE, DELETE)
- `SELECT count(*) FROM pg_policies WHERE tablename = 'import_routing_defaults';` returns 3 (SELECT, INSERT/UPSERT, UPDATE)
- `SELECT proname FROM pg_proc WHERE proname = 'update_routing_rule_priorities';` returns 1 row
  </verify>
  <done>Both tables exist in production with RLS enabled, policies active, compound index created, and update_routing_rule_priorities RPC callable.</done>
</task>

<task type="auto">
  <name>Task 2: Create routing engine and integrate into connector pipeline</name>
  <files>supabase/functions/_shared/routing-engine.ts, supabase/functions/_shared/connector-pipeline.ts</files>
  <action>
**Create `routing-engine.ts`** — a pure TypeScript module with no side effects beyond DB reads:

Export `RoutingDestination` interface: `{ vaultId: string, folderId: string | null, matchedRuleId: string, matchedRuleName: string }`

Export `resolveRoutingDestination(supabase, bankId, record: ConnectorRecord)` async function:
1. Query `import_routing_rules` for the bank: `.eq('bank_id', bankId).eq('enabled', true).order('priority', { ascending: true })`
2. For each rule, evaluate conditions against the record using `evaluateRule()`
3. Return first match as RoutingDestination, or null if no rules match

Internal functions (not exported):
- `evaluateRule(rule, record)` — evaluates all conditions with AND/OR logic
- `evaluateCondition(condition, record)` — switch on condition.field: title, source, duration, participant, tag, date
- `evaluateString(actual, operator, expected)` — case-insensitive: contains, not_contains, equals, starts_with
- `evaluateNumber(actual, operator, expected)` — greater_than, less_than, equals
- `extractParticipants(record)` — extracts from source_metadata.calendar_invitees (email/name arrays)

Import `ConnectorRecord` type from `./connector-pipeline.ts`. Import `SupabaseClient` from esm.sh.

**Modify `connector-pipeline.ts`** — add routing resolution inside `runPipeline()`:

After the dedup check succeeds (not duplicate) and BEFORE calling `insertRecording()`:
1. If `record.vault_id` is NOT already set (connector didn't specify explicit destination):
   a. Resolve bank_id: Use `record.bank_id` if provided, otherwise resolve personal bank via existing pattern in `insertRecording()`
   b. Call `resolveRoutingDestination(supabase, bankId, record)`
   c. If routing returns a match: set `record.vault_id = routing.vaultId`, merge routing trace into `record.source_metadata` (`routed_by_rule_id`, `routed_by_rule_name`, `routed_at`)
   d. If no routing match: query `import_routing_defaults` for the bank. If default exists, set `record.vault_id = default.target_vault_id`
   e. If neither routing nor default: do nothing (insertRecording falls back to personal vault — existing behavior preserved)

Also add `folder_id?: string` to the `ConnectorRecord` interface. When routing sets a destination with a folder, set `record.folder_id = routing.folderId`. In `insertRecording()`, if `record.folder_id` is set and truthy, pass it to the `vault_entries` INSERT as `folder_id`.

CRITICAL: Do NOT change the `insertRecording()` function signature. The routing logic lives in `runPipeline()` only. Connectors calling `insertRecording()` directly bypass routing — this is acceptable per research pitfall 5.

Import `resolveRoutingDestination` from `./routing-engine.ts` at top of connector-pipeline.ts.
  </action>
  <verify>
TypeScript compilation check: `deno check supabase/functions/_shared/routing-engine.ts` and `deno check supabase/functions/_shared/connector-pipeline.ts` — no errors.
Verify imports resolve: routing-engine.ts imports ConnectorRecord from connector-pipeline.ts, connector-pipeline.ts imports resolveRoutingDestination from routing-engine.ts.
Manual review: `runPipeline()` now has routing resolution between dedup check and insertRecording call.
  </verify>
  <done>routing-engine.ts exists with resolveRoutingDestination() implementing first-match-wins evaluation for 6 condition types. connector-pipeline.ts's runPipeline() calls routing resolution before insert. folder_id added to ConnectorRecord and passed through to vault_entries insert. Existing connectors continue to work unchanged.</done>
</task>

</tasks>

<verification>
- Migration deployed to production: both tables exist with RLS
- routing-engine.ts evaluates all 6 condition types: title, participant, source, duration, tag, date
- connector-pipeline.ts integrates routing without changing insertRecording signature
- Routing trace stored in source_metadata (routed_by_rule_id, routed_by_rule_name, routed_at)
- folder_id flows through ConnectorRecord to vault_entries insert
</verification>

<success_criteria>
1. `import_routing_rules` table exists in production with priority INTEGER column (IMP-10)
2. `import_routing_defaults` table exists in production
3. RLS policies enforce bank membership access on both tables
4. `update_routing_rule_priorities` RPC exists and is callable
5. `resolveRoutingDestination()` returns first matching rule's destination or null
6. `runPipeline()` resolves routing before inserting, falls back to default destination, then personal vault
</success_criteria>

<output>
After completion, create `.planning/phases/18-import-routing-rules/18-01-SUMMARY.md`
</output>
