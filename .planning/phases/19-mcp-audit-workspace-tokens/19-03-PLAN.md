---
phase: 19-mcp-audit-workspace-tokens
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - /Users/Naegele/dev/brain/supabase/migrations/20260228000001_workspace_mcp_tokens.sql
  - /Users/Naegele/dev/brain/supabase/functions/generate-mcp-token/index.ts
autonomous: true

must_haves:
  truths:
    - "workspace_mcp_tokens table exists with RLS enabled and policies enforcing workspace admin access"
    - "Edge Function generate-mcp-token creates tokens, enforces tier limits, and returns show-once secret"
    - "Token hash is stored (SHA-256), never the plaintext secret"
    - "Tier limits enforced: Free=0, Pro=5, Team=25 tokens per workspace"
  artifacts:
    - path: "/Users/Naegele/dev/brain/supabase/migrations/20260228000001_workspace_mcp_tokens.sql"
      provides: "workspace_mcp_tokens table with RLS"
      contains: "workspace_mcp_tokens"
    - path: "/Users/Naegele/dev/brain/supabase/functions/generate-mcp-token/index.ts"
      provides: "Token generation Edge Function"
      contains: "cv_mcp_"
  key_links:
    - from: "/Users/Naegele/dev/brain/supabase/functions/generate-mcp-token/index.ts"
      to: "/Users/Naegele/dev/brain/supabase/migrations/20260228000001_workspace_mcp_tokens.sql"
      via: "supabase.from('workspace_mcp_tokens').insert()"
      pattern: "workspace_mcp_tokens"
    - from: "/Users/Naegele/dev/brain/supabase/functions/generate-mcp-token/index.ts"
      to: "vault_memberships"
      via: "admin role check query"
      pattern: "vault_memberships.*vault_owner.*vault_admin"
---

<objective>
Create the workspace_mcp_tokens database table with RLS policies and the generate-mcp-token Edge Function that creates scoped, hashed tokens with tier enforcement.

Purpose: MCP-04 requires per-workspace token generation. This plan builds the data layer and server-side token creation logic independently of the Worker auth path (Plan 04) and the frontend UI (Plan 05).

Output: Database migration deployed, Edge Function deployed and testable via curl.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-CONTEXT.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace_mcp_tokens migration</name>
  <files>/Users/Naegele/dev/brain/supabase/migrations/20260228000001_workspace_mcp_tokens.sql</files>
  <action>
Create the database migration for the `workspace_mcp_tokens` table. Follow the established migration patterns from `supabase/migrations/20260131000006_create_vaults_tables.sql`.

**Table schema:**

```sql
CREATE TABLE IF NOT EXISTS public.workspace_mcp_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL REFERENCES public.vaults(id) ON DELETE CASCADE,
  creator_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL CHECK (length(name) >= 1 AND length(name) <= 100),
  token_hash TEXT NOT NULL UNIQUE,
  scoped_folder_ids UUID[] DEFAULT NULL,
  is_revoked BOOLEAN NOT NULL DEFAULT FALSE,
  revoked_at TIMESTAMPTZ,
  revoked_by UUID REFERENCES auth.users(id),
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Key design decisions per CONTEXT.md:
- `scoped_folder_ids UUID[] DEFAULT NULL` -- NULL means whole workspace scope, empty array means zero scope (returns no data)
- `is_revoked` instead of deleting rows -- soft delete preserves audit trail
- `last_used_at` updated periodically (once per hour) by Worker -- not set at creation
- `token_hash` is SHA-256 hex of the `cv_mcp_...` token string -- never stores plaintext

**Indexes:**

```sql
CREATE INDEX idx_workspace_mcp_tokens_workspace_id ON workspace_mcp_tokens(workspace_id);
CREATE UNIQUE INDEX idx_workspace_mcp_tokens_token_hash ON workspace_mcp_tokens(token_hash);
CREATE INDEX idx_workspace_mcp_tokens_creator ON workspace_mcp_tokens(creator_user_id);
CREATE INDEX idx_workspace_mcp_tokens_active ON workspace_mcp_tokens(workspace_id, is_revoked) WHERE is_revoked = FALSE;
```

Note: `token_hash` already has a UNIQUE constraint which creates an implicit index, but use CREATE UNIQUE INDEX for clarity.

**RLS policies:**

Use `is_vault_member` and related SECURITY DEFINER helper functions already established in the codebase. Check the existing migrations for the exact function signatures available.

Read `/Users/Naegele/dev/brain/supabase/migrations/20260131000006_create_vaults_tables.sql` to find the available helper functions. Expected: `is_vault_member(vault_id, user_id)`. There may also be `is_vault_admin_or_owner` or similar -- use what exists.

If `is_vault_admin_or_owner` does not exist, create a SECURITY DEFINER function:

```sql
CREATE OR REPLACE FUNCTION is_vault_admin_or_owner(p_vault_id UUID, p_user_id UUID)
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT EXISTS (
    SELECT 1 FROM vault_memberships
    WHERE vault_id = p_vault_id
      AND user_id = p_user_id
      AND role IN ('vault_owner', 'vault_admin')
  )
$$;
```

**RLS policies (4 total):**

```sql
ALTER TABLE workspace_mcp_tokens ENABLE ROW LEVEL SECURITY;

-- SELECT: workspace admins/owners can view tokens for their workspace
CREATE POLICY "workspace_admins_select_mcp_tokens"
  ON workspace_mcp_tokens FOR SELECT
  USING (is_vault_admin_or_owner(workspace_id, auth.uid()));

-- UPDATE: workspace admins/owners can revoke tokens (update is_revoked, revoked_at, revoked_by)
CREATE POLICY "workspace_admins_update_mcp_tokens"
  ON workspace_mcp_tokens FOR UPDATE
  USING (is_vault_admin_or_owner(workspace_id, auth.uid()));

-- No INSERT policy from client -- Edge Function uses service role
-- No DELETE policy -- soft delete via is_revoked (audit trail)
```

**Updated_at trigger:**

```sql
CREATE OR REPLACE FUNCTION update_workspace_mcp_tokens_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER workspace_mcp_tokens_updated_at
  BEFORE UPDATE ON workspace_mcp_tokens
  FOR EACH ROW
  EXECUTE FUNCTION update_workspace_mcp_tokens_updated_at();
```

**Apply the migration:**

```bash
cd /Users/Naegele/dev/brain
npx supabase db push
```

If `supabase db push` is not available or fails, use:
```bash
npx supabase migration up --linked
```

Or apply directly via psql if needed. Check existing patterns in STATE.md for how migrations have been applied previously.
  </action>
  <verify>
Verify the table exists and RLS is enabled:
```bash
cd /Users/Naegele/dev/brain && npx supabase db diff --linked 2>/dev/null || echo "Check migration applied via Supabase Dashboard"
```
Alternatively, use the Supabase Management API or SQL Editor to confirm:
- Table `workspace_mcp_tokens` exists
- RLS is enabled
- 2 policies exist (select + update)
- Indexes exist
  </verify>
  <done>workspace_mcp_tokens table created with RLS policies enforcing workspace admin access. No INSERT or DELETE from client -- only via service role Edge Function.</done>
</task>

<task type="auto">
  <name>Task 2: Create generate-mcp-token Edge Function</name>
  <files>/Users/Naegele/dev/brain/supabase/functions/generate-mcp-token/index.ts</files>
  <action>
Create the Edge Function that generates MCP tokens. Follow the established Edge Function pattern from `supabase/CLAUDE.md`.

Read `supabase/CLAUDE.md` first for the mandatory patterns (CORS headers, auth pattern, error handling).

**Function: `supabase/functions/generate-mcp-token/index.ts`**

The function must:

1. **Authenticate the request** using the standard Bearer token pattern (extract JWT, verify with `supabase.auth.getUser(token)`).

2. **Validate input** with Zod:
   ```typescript
   const bodySchema = z.object({
     workspace_id: z.string().uuid(),
     name: z.string().min(1).max(100),
     scoped_folder_ids: z.array(z.string().uuid()).nullable().optional(),
   });
   ```

3. **Check workspace admin role**: Query `vault_memberships` for the user's role in the workspace. Only `vault_owner` and `vault_admin` can create tokens.

4. **Enforce tier limits** per CONTEXT.md decision:
   - Free: 0 tokens (MCP is the free/paid paywall)
   - Pro: 5 tokens per workspace
   - Team: 25 tokens per workspace
   - Admin: 999 tokens (effectively unlimited)

   Query `user_roles` table for the user's role. Map role to limit. Count existing active (non-revoked) tokens for the workspace.

   If Free tier: return 403 with `{ error: "MCP tokens require a Pro or Team plan", upgrade_required: true }`.
   If at limit: return 403 with `{ error: "Token limit reached (N per workspace on your plan)" }`.

5. **Generate the token secret**:
   - Format: `cv_mcp_` + 64 hex characters (32 bytes of `crypto.getRandomValues`)
   - Total length: 71 characters
   - Hash with SHA-256 for storage: `crypto.subtle.digest('SHA-256', ...)`
   - Convert hash to hex string

6. **Insert token record** using service role client:
   ```typescript
   const adminSupabase = createClient(
     Deno.env.get('SUPABASE_URL')!,
     Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
     { auth: { autoRefreshToken: false, persistSession: false } }
   );
   ```

   Insert into `workspace_mcp_tokens`:
   - `workspace_id`, `creator_user_id` (from auth), `name`, `token_hash`, `scoped_folder_ids` (null if not provided or null)

7. **Return the token secret** (show-once):
   ```json
   {
     "token_secret": "cv_mcp_...",
     "token_id": "uuid",
     "name": "My Token",
     "workspace_id": "uuid",
     "scoped_folder_ids": null,
     "created_at": "2026-02-28T..."
   }
   ```

   The `token_secret` is the ONLY time the plaintext token is available. After this response, only the hash exists.

**Also create a revoke endpoint in the same function** (or handle as a separate method). Since Edge Functions map to a single route, use the request body to determine the action:

Actually, revocation can be done directly from the frontend via Supabase client (the UPDATE RLS policy allows admins to update tokens). The frontend can call:
```typescript
supabase.from('workspace_mcp_tokens')
  .update({ is_revoked: true, revoked_at: new Date().toISOString(), revoked_by: userId })
  .eq('id', tokenId)
```

This works because the UPDATE RLS policy uses `is_vault_admin_or_owner`. So no separate revoke Edge Function is needed.

**Deploy the Edge Function:**
```bash
cd /Users/Naegele/dev/brain
npx supabase functions deploy generate-mcp-token --no-verify-jwt
```

Wait -- the function should verify JWT. Check if `supabase/config.toml` needs an entry. The function authenticates manually via `supabase.auth.getUser(token)` using the service role client, so `verify_jwt` can be false at the Supabase level (the function handles its own auth). This is the pattern used by other functions in the project. Read `supabase/config.toml` to confirm the pattern.

Actually, re-read the auth pattern: the function creates a service role client to do the admin operations, but first validates the caller's JWT via `supabase.auth.getUser(token)`. The `verify_jwt` config just controls whether Supabase Gateway rejects requests without valid JWTs before they reach the function. Setting `verify_jwt = true` adds an extra layer but means the function can trust `req.headers.get('Authorization')` is valid. Either works -- follow existing project pattern from config.toml.

**Test with curl:**

```bash
# Get a test JWT first (same as Plan 01)
TOKEN=$(curl -s -X POST "https://vltmrnjsubfzrgrtdqey.supabase.co/auth/v1/token?grant_type=password" \
  -H "apikey: <ANON_KEY>" \
  -H "Content-Type: application/json" \
  -d '{"email":"<EMAIL>","password":"<PASSWORD>"}' | python3 -c "import sys,json; print(json.load(sys.stdin)['access_token'])")

# Test token generation
curl -s -X POST "https://vltmrnjsubfzrgrtdqey.supabase.co/functions/v1/generate-mcp-token" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"workspace_id":"<A_REAL_WORKSPACE_ID>","name":"Test Token"}' | python3 -m json.tool
```

To find a real workspace_id, query the vaults table:
```bash
curl -s "https://vltmrnjsubfzrgrtdqey.supabase.co/rest/v1/vaults?select=id,name&limit=1" \
  -H "Authorization: Bearer $TOKEN" \
  -H "apikey: <ANON_KEY>" | python3 -m json.tool
```

Verify:
- Response contains `token_secret` starting with `cv_mcp_`
- Response contains `token_id`, `name`, `workspace_id`, `created_at`
- A second call to generate should also succeed (unless at tier limit)
- Token row exists in DB (can verify via Supabase Dashboard or SQL query)
  </action>
  <verify>
The Edge Function is deployed and responds:
```bash
curl -s -X POST "https://vltmrnjsubfzrgrtdqey.supabase.co/functions/v1/generate-mcp-token" \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"workspace_id":"<ID>","name":"verify-test"}' | python3 -m json.tool
```
Returns 200 with `token_secret` field starting with `cv_mcp_`.
  </verify>
  <done>generate-mcp-token Edge Function deployed. Generates cv_mcp_ prefixed tokens, stores SHA-256 hash, enforces tier limits (Free=0, Pro=5, Team=25), validates workspace admin role. Token secret returned once (show-once pattern).</done>
</task>

</tasks>

<verification>
- `workspace_mcp_tokens` table exists in Supabase with RLS enabled
- 2 RLS policies active (select, update) both checking workspace admin/owner role
- `generate-mcp-token` Edge Function deployed
- Token generation returns `cv_mcp_` prefixed secret
- Token hash stored in DB (verify via Dashboard)
- Tier enforcement works (Free tier returns 403 with upgrade_required)
- Non-admin workspace member gets 403
</verification>

<success_criteria>
Token infrastructure is operational: DB table stores hashed tokens with RLS, Edge Function creates tokens with tier enforcement. Ready for Worker auth integration (Plan 04) and frontend UI (Plan 05).
</success_criteria>

<output>
After completion, create `.planning/phases/19-mcp-audit-workspace-tokens/19-03-SUMMARY.md`
</output>
