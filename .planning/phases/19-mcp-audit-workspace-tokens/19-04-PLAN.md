---
phase: 19-mcp-audit-workspace-tokens
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts
  - /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts
autonomous: true

must_haves:
  truths:
    - "Worker accepts cv_mcp_ prefixed bearer tokens and validates them against workspace_mcp_tokens table"
    - "Token validation checks CURRENT workspace membership at query time (P9 pitfall prevented)"
    - "MCP token auth path scopes all queries to the token's workspace_id"
    - "Folder-scoped tokens only return data from the specified folders"
    - "last_used_at updates at most once per hour using ctx.waitUntil"
    - "Revoked tokens are rejected immediately"
  artifacts:
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      provides: "validateMcpToken function"
      contains: "cv_mcp_"
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts"
      provides: "RequestContext with tokenWorkspaceId and tokenScopedFolderIds"
      contains: "tokenWorkspaceId"
    - path: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      provides: "Two-path auth routing (JWT vs MCP token)"
      contains: "cv_mcp_"
  key_links:
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts"
      to: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      via: "validateMcpToken import and call"
      pattern: "validateMcpToken"
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      to: "workspace_mcp_tokens"
      via: "service role Supabase client query"
      pattern: "workspace_mcp_tokens.*token_hash"
    - from: "/Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts"
      to: "vault_memberships"
      via: "live membership check at query time"
      pattern: "vault_memberships.*user_id"
---

<objective>
Add MCP opaque token validation to the Cloudflare Worker, with service-role scoping and handler-level workspace filtering. Tokens starting with `cv_mcp_` are validated against the `workspace_mcp_tokens` table, with live membership checks at query time.

Purpose: MCP-04 (per-workspace token generation) and MCP-07 (RLS workspace isolation) require the Worker to accept and validate opaque MCP tokens alongside existing OAuth JWTs. The P9 pitfall (stale membership) is prevented by checking CURRENT vault_memberships on every request.

Output: Worker deployed with two-path auth. MCP tokens scope all queries to the token's workspace. Verified via curl with a real token from Plan 03.
</objective>

<execution_context>
@/Users/Naegele/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Naegele/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-CONTEXT.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-RESEARCH.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-02-SUMMARY.md
@.planning/phases/19-mcp-audit-workspace-tokens/19-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validateMcpToken and two-path auth to Worker</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/auth-middleware.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/worker.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/types.ts
  </files>
  <action>
Read the current `auth-middleware.ts`, `worker.ts`, and `types.ts` first to understand the existing auth flow.

**Step 1: Add SUPABASE_SERVICE_ROLE_KEY to Worker secrets**

Before making code changes, add the service role key as a Cloudflare secret:

```bash
cd /Users/Naegele/Developer/mcp/callvault-mcp
# Get the service role key from brain/.env.local
grep SUPABASE_SERVICE_ROLE_KEY /Users/Naegele/dev/brain/.env.local
# Then set it as a Worker secret
echo "<SERVICE_ROLE_KEY>" | wrangler secret put SUPABASE_SERVICE_ROLE_KEY
```

Also update the `Env` interface in `types.ts` (or wherever the Worker env is typed) to include `SUPABASE_SERVICE_ROLE_KEY: string`.

**Step 2: Update types.ts**

Add to `RequestContext`:
```typescript
export interface RequestContext {
  supabase: SupabaseClient;
  userId: string;
  // Set only for MCP token auth path (not OAuth)
  tokenWorkspaceId?: string;
  tokenScopedFolderIds?: string[] | null; // null = whole workspace, [] = empty scope
}
```

Add the `McpTokenValidationResult` type:
```typescript
export interface McpTokenValidationResult {
  valid: boolean;
  error?: string;
  userId?: string;
  workspaceId?: string;
  scopedFolderIds?: string[] | null;
}
```

Add `SUPABASE_SERVICE_ROLE_KEY` to the `Env` interface.

**Step 3: Create validateMcpToken in auth-middleware.ts**

Add this function to `auth-middleware.ts`:

```typescript
export async function validateMcpToken(
  token: string,
  env: Env
): Promise<McpTokenValidationResult> {
  // Create service role client for admin queries
  const adminSupabase = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY, {
    auth: { autoRefreshToken: false, persistSession: false }
  });

  // Hash the incoming token with SHA-256
  const hashBuffer = await crypto.subtle.digest(
    'SHA-256',
    new TextEncoder().encode(token)
  );
  const tokenHash = Array.from(new Uint8Array(hashBuffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');

  // Look up token by hash
  const { data: tokenRow, error: lookupError } = await adminSupabase
    .from('workspace_mcp_tokens')
    .select('id, user_id, workspace_id, scoped_folder_ids, is_revoked, last_used_at')
    .eq('token_hash', tokenHash)
    .eq('is_revoked', false)
    .maybeSingle();

  if (lookupError || !tokenRow) {
    return { valid: false, error: 'Token not found or revoked' };
  }

  // P9 PITFALL PREVENTION: Check CURRENT membership, not cached/baked claims
  const { data: membership, error: memberError } = await adminSupabase
    .from('vault_memberships')
    .select('role')
    .eq('vault_id', tokenRow.workspace_id)
    .eq('user_id', tokenRow.user_id)
    .maybeSingle();

  if (memberError || !membership) {
    return { valid: false, error: 'Token owner no longer has access to this workspace' };
  }

  return {
    valid: true,
    userId: tokenRow.user_id,
    workspaceId: tokenRow.workspace_id,
    scopedFolderIds: tokenRow.scoped_folder_ids,
  };
}
```

Also add a function for non-blocking last_used_at update:

```typescript
export async function updateTokenLastUsed(
  tokenHash: string,
  lastUsedAt: string | null,
  env: Env,
  ctx: ExecutionContext
): void {
  // Only update if more than 1 hour old (per CONTEXT.md decision)
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
  if (lastUsedAt && lastUsedAt > oneHourAgo) {
    return; // Recent enough, skip update
  }

  // Use ctx.waitUntil for non-blocking update (Cloudflare Workers pattern)
  ctx.waitUntil(
    (async () => {
      const adminSupabase = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY, {
        auth: { autoRefreshToken: false, persistSession: false }
      });
      await adminSupabase
        .from('workspace_mcp_tokens')
        .update({ last_used_at: new Date().toISOString() })
        .eq('token_hash', tokenHash);
    })()
  );
}
```

Wait -- `updateTokenLastUsed` needs the raw tokenHash and lastUsedAt. Restructure: `validateMcpToken` should return `tokenHash` and `lastUsedAt` in its result so the caller can pass them to the update function. Add these to `McpTokenValidationResult`:

```typescript
export interface McpTokenValidationResult {
  valid: boolean;
  error?: string;
  userId?: string;
  workspaceId?: string;
  scopedFolderIds?: string[] | null;
  tokenHash?: string;     // for last_used_at update
  lastUsedAt?: string | null; // for staleness check
}
```

**Step 4: Update worker.ts with two-path auth**

Read the current auth flow in `worker.ts`. It should extract the Bearer token and validate via `validateSupabaseToken` (or similar function name). Add a branch:

```typescript
const authHeader = request.headers.get('Authorization');
if (!authHeader?.startsWith('Bearer ')) {
  return unauthorized401(url);
}

const token = authHeader.slice(7);

let context: RequestContext;

if (token.startsWith('cv_mcp_')) {
  // MCP opaque token path
  const result = await validateMcpToken(token, env);
  if (!result.valid) {
    return new Response(JSON.stringify({ error: result.error }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  // Use service role client — MCP tokens are NOT Supabase JWTs
  // CRITICAL: Do NOT pass the opaque token to Supabase as Bearer
  const supabase = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY, {
    auth: { autoRefreshToken: false, persistSession: false }
  });

  context = {
    supabase,
    userId: result.userId!,
    tokenWorkspaceId: result.workspaceId!,
    tokenScopedFolderIds: result.scopedFolderIds ?? null,
  };

  // Non-blocking last_used_at update
  updateTokenLastUsed(result.tokenHash!, result.lastUsedAt ?? null, env, ctx);
} else {
  // Existing OAuth JWT path — keep exactly as-is
  // ... existing validateSupabaseToken logic ...
}
```

**CRITICAL:** The service-role client for MCP token path bypasses RLS. Workspace scoping MUST be enforced at the handler level via `context.tokenWorkspaceId`. This is handled in Task 2.

**Note about `ctx`:** In Cloudflare Workers, the `ExecutionContext` is passed to the `fetch` handler. Ensure `ctx` is accessible where `updateTokenLastUsed` is called. Read the current `worker.ts` to see if `ctx` is already available or if it needs to be threaded through.
  </action>
  <verify>
Run TypeScript type-check:
```bash
cd /Users/Naegele/Developer/mcp/callvault-mcp && npx tsc --noEmit
```
Zero errors.
  </verify>
  <done>Two-path auth implemented: cv_mcp_ tokens validated against workspace_mcp_tokens table with live membership check (P9 pitfall prevented). Service-role client used for MCP token path. last_used_at updated non-blockingly via ctx.waitUntil.</done>
</task>

<task type="auto">
  <name>Task 2: Add workspace scope enforcement to handlers, deploy, and verify</name>
  <files>
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/navigation.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/recordings.ts
    /Users/Naegele/Developer/mcp/callvault-mcp/src/handlers/index.ts
  </files>
  <action>
Since the MCP token auth path uses a service-role Supabase client (bypasses RLS), handlers must explicitly filter by workspace when `context.tokenWorkspaceId` is set.

Read all handler files to understand the current query patterns.

**Scope enforcement approach:**

For each handler that queries data, when `context.tokenWorkspaceId` is set:

1. **navigation.listOrganizations**: Return only the organization that owns the token's workspace. Query `vaults` to get `bank_id` for the workspace, then return only that organization from `bank_memberships`.

2. **navigation.listWorkspaces**: Only return the token's workspace (filter by `id = context.tokenWorkspaceId`).

3. **navigation.listFolders**: If `context.tokenScopedFolderIds` is non-null (array), filter to only those folder IDs. If null (whole workspace scope), return all folders for the workspace.

4. **recordings.list / recordings.search / recordings.get**: Filter `vault_entries` by `vault_id = context.tokenWorkspaceId`. If `context.tokenScopedFolderIds` is non-null, additionally filter `vault_entries.folder_id` to be IN that array.

5. **transcripts handlers**: These look up by recording ID. The recording access is already gated by vault_entries in the recordings lookup. Add a check: verify the recording belongs to the token's workspace before returning transcript data.

6. **contacts handlers**: Filter by workspace scope -- contacts linked to recordings in the scoped workspace only.

7. **search.semantic**: If it calls a Supabase Edge Function, pass workspace_id as a filter parameter.

8. **analysis handlers**: Scope to workspace.

**Implementation pattern:**

Create a helper function in `handlers/index.ts` or a new `handlers/scope.ts`:

```typescript
export function applyTokenScope(
  query: any,
  context: RequestContext,
  options: {
    workspaceColumn?: string; // default 'vault_id'
    folderColumn?: string;    // default 'folder_id'
  } = {}
) {
  if (!context.tokenWorkspaceId) return query; // OAuth path, RLS handles it

  const wsCol = options.workspaceColumn || 'vault_id';
  const fCol = options.folderColumn || 'folder_id';

  query = query.eq(wsCol, context.tokenWorkspaceId);

  if (context.tokenScopedFolderIds !== null && context.tokenScopedFolderIds !== undefined) {
    if (context.tokenScopedFolderIds.length === 0) {
      // Empty scope = no data. Return impossible filter.
      query = query.eq(fCol, '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in(fCol, context.tokenScopedFolderIds);
    }
  }

  return query;
}
```

Apply this helper to all handlers that query vault_entries or recordings. For handlers that don't directly query these tables, add workspace filtering at the appropriate level.

**Deploy and verify:**

```bash
cd /Users/Naegele/Developer/mcp/callvault-mcp
unset CLOUDFLARE_API_TOKEN
wrangler deploy
```

**Verify with a real MCP token:**

Use a token created in Plan 03 Task 2. If no token was created yet, create one via curl first:

```bash
# Create a token via the Edge Function
TOKEN_RESPONSE=$(curl -s -X POST "https://vltmrnjsubfzrgrtdqey.supabase.co/functions/v1/generate-mcp-token" \
  -H "Authorization: Bearer <JWT>" \
  -H "Content-Type: application/json" \
  -d '{"workspace_id":"<WORKSPACE_ID>","name":"Auth Test"}')
MCP_TOKEN=$(echo $TOKEN_RESPONSE | python3 -c "import sys,json; print(json.load(sys.stdin)['token_secret'])")
```

Then test with the MCP token:

1. Initialize:
```bash
curl -s -X POST https://callvault-mcp.naegele412.workers.dev/mcp \
  -H "Authorization: Bearer $MCP_TOKEN" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"token-test","version":"1.0"}}}'
```

2. Discover and execute operations:
```bash
# Should only return the token's workspace, not all workspaces
curl -s -X POST https://callvault-mcp.naegele412.workers.dev/mcp \
  -H "Authorization: Bearer $MCP_TOKEN" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Mcp-Session-Id: <SESSION>" \
  -d '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"callvault_execute","arguments":{"operation":"navigation.list_workspaces","params":{"organization_id":"<ORG_ID>"}}}}'
```

3. **MCP-07 isolation test**: Verify the token CANNOT access a different workspace:
   - Execute `recordings.list` with a vault_id that belongs to a DIFFERENT workspace than the token's scope
   - Should return empty results or an error, NOT recordings from that other workspace

4. Verify a revoked token is rejected:
   - Revoke the token via SQL: `UPDATE workspace_mcp_tokens SET is_revoked = true WHERE name = 'Auth Test'`
   - Retry the same request -- should get 401
  </action>
  <verify>
All of these pass:
1. MCP token auth returns 200 and real data for the scoped workspace
2. MCP token cannot access recordings from a different workspace (isolation verified)
3. Revoked token returns 401
4. TypeScript compiles clean: `cd /Users/Naegele/Developer/mcp/callvault-mcp && npx tsc --noEmit`
  </verify>
  <done>Worker deployed with MCP token auth path. Workspace isolation enforced at handler level. P9 pitfall prevented (live membership check). Revoked tokens rejected immediately. MCP-04 and MCP-07 requirements met.</done>
</task>

</tasks>

<verification>
- Worker accepts `cv_mcp_` tokens and returns scoped data
- Worker rejects revoked tokens with 401
- Worker rejects tokens for users no longer in the workspace (P9 pitfall)
- OAuth JWT path continues to work (regression check)
- All handler queries scope to tokenWorkspaceId when set
- Folder-scoped tokens only return folder-scoped data
- TypeScript compiles clean
- Worker deployed and verified with real MCP token
</verification>

<success_criteria>
MCP-04 satisfied: workspace owner can use a generated MCP token to authenticate to the Worker and get scoped data. MCP-07 satisfied: scoped token cannot read recordings from other workspaces, verified with real token and real data. P9 pitfall prevented: membership checked at query time, not issuance time.
</success_criteria>

<output>
After completion, create `.planning/phases/19-mcp-audit-workspace-tokens/19-04-SUMMARY.md`
</output>
